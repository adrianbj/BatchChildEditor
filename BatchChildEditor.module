<?php

/**
 * ProcessWire Batch creation and editing of child page titles
 * by Adrian Jones
 *
 * Quick batch editing of all child page, so long as they only have a title field.
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class BatchChildEditor extends WireData implements Module, ConfigurableModule {

    public static function getModuleInfo() {
        return array(
            'title' => 'Batch child editor',
            'summary' => 'Quick batch creation and editing of child page titles and names.',
            'href' => 'http://modules.processwire.com/modules/batch-child-editor/',
            'version' => 52,
            'permanent' => false,
            'autoload' => true,
            'icon'     => 'child'
        );
    }


    /**
     * Data as used by the get/set functions
     *
     */
    protected $data = array();
    protected $childPages = '';


   /**
     * Default configuration for module
     *
     */
    static public function getDefaultData() {
            return array(
                "enabledTemplates" => array(),
                "enabledPages" => array(),
                "configurablePages" => array(),
                "editModes" => "edit",
                "overwriteNames" => "",
                "allowOverrideOverwriteNames" => "",
                "loadOpen" => "",
                "csvOptions" => "",
                "fieldSeparator" => ",",
                "fieldEnclosure" => '"',
                "ignoreFirstRow" => 0,
                "fieldPairings" => "",
                "trashOrDelete" => "trash",
                "position" => "bottom",
                "tabName" => "Batch Child Editor",
                "disableContentProtection" => "",
                "editModeTitle" => "Edit Child Pages",
                "editModeDescription" => "You can edit the page titles, sort, delete, add new, or edit pages in a modal popup (via the page name link).",
                "editModeNotes" => "",
                "addModeTitle" => "Add Child Pages",
                "addModeDescription" => "Editing this field will add all the child page titles listed here to the existing set of child pages.",
                "addModeNotes" => "Each row is a separate page.\n\nYou can also use CSV formatted lines for populating all text/numeric fields on the page, eg:\n\"Bolivia, Plurinational State of\",BO,\"BOLIVIA, PLURINATIONAL STATE OF\",BOL,68",
                "updateModeTitle" => "Update Child Pages",
                "updateModeDescription" => "Editing this field will update the field values of the pages represented here.",
                "updateModeNotes" => "WARNING: If you use this option, the content of all fields in existing pages will be replaced.\n\nEach row is a separate page.\n\nYou can also use CSV formatted lines for populating all text/numeric fields on the page, eg:\n\"Bolivia, Plurinational State of\",BO,\"BOLIVIA, PLURINATIONAL STATE OF\",BOL,68",
                "replaceModeTitle" => "Replace Child Pages",
                "replaceModeDescription" => "Editing this field will replace all the child page titles represented here.",
                "replaceModeNotes" => "WARNING: If you use this option, all the existing child pages (and grandchildren) will be deleted and new ones created.\n\nEach row is a separate page.\n\nYou can also use CSV formatted lines for populating all text/numeric fields on the page, eg:\n\"Bolivia, Plurinational State of\",BO,\"BOLIVIA, PLURINATIONAL STATE OF\",BOL,68",
                "pageSettings" => array(),
            );
    }

    /**
     * Populate the default config data
     *
     */
    public function __construct() {
       foreach(self::getDefaultData() as $key => $value) {
               $this->$key = $value;
       }
    }


    public function init() {
        $this->addHookAfter("ProcessPageEdit::buildFormChildren", $this, "addScript");
    }

    public function addScript($event){
        $conf = $this->getModuleInfo();
        $version = (int) $conf['version'];
         wire("config")->scripts->add($this->config->urls->BatchChildEditor . "BatchChildEditor.js?v={$version}");
    }

    public function ready() {

        if(!$this->user->hasPermission("batch-child-editor")) return;

        // we're interested in page editor only
        if(wire('page')->process != 'ProcessPageEdit') return;

        $id = (int)$this->input->get->id;
        if(!$id) return;

        //populate currentData with pageSettings version if page has specific settings
        $currentData = isset($this->data['pageSettings'][$id]) && $this->data['pageSettings'][$id] ? $this->data['pageSettings'][$id] : $this->data;

        // GET parameter id tells the page that's being edited
        $this->editedPage = wire('pages')->get($id);

        // don't even consider system templates
        if($this->editedPage->template->flags & Template::flagSystem) return;

        // if any templates or pages have been selected, then only hook if the template of the edited page has been chosen or the page has been chosen
        //if(count($this->data['enabledTemplates']) === 0 && count($this->data['enabledPages']) === 0) return;
        if(count($this->data['enabledTemplates']) !== 0 && !in_array($this->editedPage->template->name, $this->data['enabledTemplates'])) return;
        if(count($this->data['enabledPages']) !== 0 && !in_array($this->editedPage->id, $this->data['enabledPages'])) return;

        //Make sure at least one edit mode has been selected in the config
        if(count($currentData['editModes']) == 0) return;

        //if position is "new tab" we also need to check that the template family settings allow the page to have children
        if($currentData['position'] == 'newTab' && !$this->editedPage->template->noChildren) {
            $this->addHookAfter('ProcessPageEdit::buildFormContent', $this, 'addNewTab');
        }
        else {
            $this->addHookAfter('ProcessPageEdit::buildFormChildren', $this, 'addChildEditFieldset');
        }
        $this->addHookAfter('ProcessPageEdit::processInput', $this, 'saveChildren');

        // page specific config settings
        if($this->user->isSuperuser() && count($this->data['configurablePages']) !== 0 && in_array($this->editedPage->id, $this->data['configurablePages'])) {
            $this->addHookAfter('ProcessPageEdit::buildFormSettings', $this, 'buildPageConfigForm');
            $this->addHookAfter('ProcessPageEdit::processInput', $this, 'processPageConfigForm');
        }

    }



    public function buildPageConfigForm(HookEvent $event){

        $pp = $event->object->getPage();

        $inputfields = $event->return;

        $fieldset = $this->modules->get("InputfieldFieldset");
        $fieldset->attr('id', 'batch_child_editor_config_fieldset');
        $fieldset->label = __("Batch Child Editor Settings");
        if(!isset($this->data['pageSettings'][$pp->id])) $fieldset->collapsed = Inputfield::collapsedYes;

        $f = wire('modules')->get("InputfieldMarkup");
        $f->attr('name', 'config_intro');
        $f->label = "";
        $f->value = "<p>These settings will override those in the main config settings for this page.</p>";
        $fieldset->append($f);

        buildCoreSettings($this->data, $fieldset, $pp->id);

        $inputfields->append($fieldset);


        // check integrity of field pairings list
        if(isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id]) {
            if($this->data['pageSettings'][$pp->id]['fieldPairings'] != '') {
                $convertedFieldPairings = $this->convertFieldPairings($this->data['pageSettings'][$pp->id]['fieldPairings']);
                // if field pairings are set, make sure a title field is defined
                // maybe we want to make this optional at some point in case template doesn't actually have/require a title field
                if(!in_array('title', $convertedFieldPairings)) {
                    if(count($this->data['pageSettings'][$pp->id]['editModes']) > 1 || (count($this->data['pageSettings'][$pp->id]['editModes']) == 1 && !in_array('update', $this->data['pageSettings'][$pp->id]['editModes']))) {
                        $this->error($this->_("You must include a \"title\" field in the CSV Field Pairings, unless the only available edit mode is \"Update\"."));
                    }
                }

                // make sure all the fields exist in the templates that are possible for child pages
                $possibleTemplates = array();
                if(count($pp->template->childTemplates)==0){
                    foreach($this->templates as $t) {
                        if(!($t->flags & Template::flagSystem)) $possibleTemplates[] = $t->name;
                    }
                }
                else{
                    foreach($pp->template->childTemplates as $t) {
                        $possibleTemplates[] = $this->templates->get($t)->name;
                    }
                }
                $missingFields = array();
                foreach($possibleTemplates as $t) {
                    foreach($convertedFieldPairings as $f) {
                        if(!$this->templates->get($t)->hasField($f)) $missingFields[] = $f;
                    }
                }
                if(!empty($missingFields)) $this->error($this->_("The following fields defined in \"Field Pairings\" are not available in any of the allowed templates for child pages: " . implode(', ', $missingFields)));
            }
        }
    }



    public function processPageConfigForm(HookEvent $event){

        // ProcessPageEdit's processInput function may go recursive, so we want to skip
        // the instances where it does that by checking the second argument named "level"
        $level = $event->arguments(1);
        if($level > 0) return;

        $p = $event->object->getPage();

        $options = array("pid" => $p->id);
        foreach(self::getDefaultData() as $key => $value) {
            $options[$key] = $this->input->post->$key;
        }

        $this->saveSettings($options);
    }


    public function saveSettings($options) {
        $pid = $options['pid'];
        unset($this->data['pageSettings'][$pid]); // remove existing record for this page - need a clear slate for adding new settings or if it was just disabled
        foreach($options as $key => $value) {
            $this->data['pageSettings'][$pid][$key] = $value;
        }

        // save to config data with the rest of the settings
        $this->modules->saveModuleConfigData($this->modules->get("BatchChildEditor"), $this->data);
    }


    public function addChildEditFieldset(HookEvent $event){

        $pp = $event->object->getPage();
        $form = $event->return;

        //populate currentData with pageSettings version if page has specific settings
        $currentData = isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        $childEditSet = $this->createChildEditSet($pp, $form);

        if($currentData['position'] == 'top') $form->prepend($childEditSet);
        elseif ($currentData['position'] == 'replace') {
            foreach($form as $field) {
                if($field->label == 'Children / Subpages') $form->remove($field);
            }
            $form->prepend($childEditSet);
        }
        else $form->append($childEditSet); // bottom
    }


    public function addNewTab(HookEvent $event){

        $pp = $event->object->getPage();
        $form = $event->return;

        //populate currentData with pageSettings version if page has specific settings
        $currentData = isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        //build the content of the tab
        $childEditSet = $this->createChildEditSet($pp, $form);

        //old approach - works, but prevents being able to position the tab anywhere but after the View tab
        //if going back to this approach, then need to change the hook that calls this method to ProcessPageEdit::buildForm
        /*
        // create the tab
        $newTab = new InputfieldWrapper();
        $newTab->attr('id', $this->className() . $this->sanitizer->pageName($currentData['tabName'],true));
        $newTab->attr('title', $currentData['tabName']);
        $newTab->prepend($childEditSet);
        $form->prepend($newTab); // this prepend is putting the childeditset before the save button, although I really want to change the order of the tab itself to just after Content
        */

        $this->modules->get('FieldtypeFieldsetTabOpen');
        $field = new InputfieldFieldsetTabOpen;
        $field->name = $this->sanitizer->pageName($currentData['tabName'],true);
        $field->label = $currentData['tabName'];
        $form->add($field);

        $form->add($childEditSet);

        $this->modules->get('FieldtypeFieldsetClose');
        $field = new InputfieldFieldsetClose;
        $field->name = $this->sanitizer->pageName($currentData['tabName'],true)."_END";
        $form->add($field);
    }


    public function createChildEditSet($pp, $form) {

        //populate currentData with pageSettings version if page has specific settings
        $currentData = isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        foreach($pp->children("include=all") as $cp) {
            if(!$cp->is(Page::statusSystemID)) $this->childPages .= "{$cp->title}\r\n";
        }
        $this->childPages = rtrim($this->childPages, "\r\n");
        if($currentData['ignoreFirstRow']) $this->childPages = "Title\r\n".$this->childPages;

        // create the fieldset
        $childEditSet = $this->modules->get("InputfieldFieldset");
        $childEditSet->attr('name', 'child_batch_editor');
        $childEditSet->label = $currentData['position'] == 'newTab' ? ' ' : $childEditSet->label = __('Batch Editor / Creator');


        if(count($currentData['editModes'])>1){
            $f = $this->modules->get("InputfieldRadios");
            $f->attr('name', 'edit_mode');
            $f->label = __('Edit, Add, Update, or Replace');
            $f->optionColumns = 1;
            $f->columnWidth = 33;
            $f->description = __('Whether to edit, add to, update, or replace the entire list of child pages. Choose an option to read more about how it works.');
            foreach($currentData['editModes'] as $editMode){
                $f->addOption($editMode, ucfirst($editMode));
            }
            $childEditSet->add($f);
        }
        else{
            $f = $this->modules->get("InputfieldHidden");
            $f->attr('name', 'edit_mode');
            $f->value = $currentData['editModes'][0];
            $childEditSet->add($f);
        }

        if(is_array($pp->template->childTemplates) && count($pp->template->childTemplates)!=1){
            $f = $this->modules->get("InputfieldSelect");
            $f->required = true;
            $f->name = "childTemplate";
            $f->showIf = "edit_mode.count>0";
            $f->label = __('Child Template');
            $f->columnWidth = 34;
            $f->description = __('Choose the template for new children');
            if(count($pp->template->childTemplates)==0){
                foreach($this->templates as $t) {
                    if(!($t->flags & Template::flagSystem)) $f->addOption($t->name);
                }
            }
            else{
                $f->addOption('');
                foreach($pp->template->childTemplates as $t) {
                    $f->addOption($this->templates->get($t)->name);
                }
            }
            if($pp->children("include=all")->count()>0 && $pp->children("include=all")->last()->id) $f->attr('value', $pp->children("include=all")->last()->template);
            $childEditSet->add($f);
        }

        if($currentData['allowOverrideOverwriteNames']){
            $f = wire('modules')->get("InputfieldCheckbox");
            $f->attr('name', 'userOverwriteNames');
            $f->showIf = "edit_mode=edit|update";
            $f->label = __('Overwrite names');
            $f->columnWidth = 33;
            $f->description = __('Whether to overwrite the name of the page, and not just the title.');
            $f->attr('checked', $currentData['overwriteNames'] ? 'checked' : '' );
            $f->notes = __("This option can cause problems if the affected child pages are part of the front end structure of the site. It may result in broken links, etc.");
            $childEditSet->add($f);
        }


        // Add
        if(in_array('add', $currentData['editModes'])) {

            if($currentData['csvOptions']) {
                $csvFieldset = $this->modules->get("InputfieldFieldset");
                $csvFieldset->label = $currentData['addModeTitle'];
                $csvFieldset->description = $currentData['addModeDescription'];
                $csvFieldset->notes = $currentData['addModeNotes'];
                $csvFieldset->showIf = "edit_mode=add";
                $childEditSet->add($csvFieldset);
            }

            if(is_array($currentData['csvOptions']) && in_array('paste', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldTextarea");
                $f->name = "childPagesAdd";
                $f->showIf = "edit_mode=add";
                $f->label = __("Paste CSV");
                $f->attr('value', '');
                $csvFieldset->append($f);
            }

            if(is_array($currentData['csvOptions']) && in_array('link', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldURL");
                $f->name = "csvUrlAdd";
                $f->showIf = "edit_mode=add";
                $f->label = __("Enter URL to CSV file");
                $f->placeholder = __("URL to CSV file");
                $f->attr('value', '');
                $csvFieldset->append($f);
            }

            if(is_array($currentData['csvOptions']) && in_array('upload', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldMarkup");
                $f->label = __("Upload CSV file");
                $f->name = 'csvUploadAdd';
                $f->showIf = "edit_mode=add";
                $f->value = "<input name='csvAddFile' type='file' />";
                $csvFieldset->add($f);
            }

        }

        // Update
        if(in_array('update', $currentData['editModes'])) {

            if($currentData['csvOptions']) {
                $csvFieldset = $this->modules->get("InputfieldFieldset");
                $csvFieldset->label = $currentData['updateModeTitle'];
                $csvFieldset->description = $currentData['updateModeDescription'];
                $csvFieldset->notes = $currentData['updateModeNotes'];
                $csvFieldset->showIf = "edit_mode=update";
                $childEditSet->add($csvFieldset);
            }

            if(in_array('paste', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldTextarea");
                $f->name = "childPagesUpdate";
                $f->showIf = "edit_mode=update";
                $f->label = __("Paste CSV");
                $f->attr('value', $this->childPages);
                $csvFieldset->append($f);
            }

            if(in_array('link', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldURL");
                $f->name = "csvUrlUpdate";
                $f->showIf = "edit_mode=update";
                $f->label = __("Enter URL to CSV file");
                $f->placeholder = __("URL to CSV file");
                $f->attr('value', '');
                $csvFieldset->append($f);
            }

            if(in_array('upload', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldMarkup");
                $f->label = __("Upload CSV file");
                $f->name = 'csvUploadUpdate';
                $f->showIf = "edit_mode=update";
                $f->value = "<input name='csvUpdateFile' type='file' />";
                $csvFieldset->add($f);
            }

        }

        // Replace
        if(in_array('replace', $currentData['editModes'])) {

            if($currentData['csvOptions']) {
                $csvFieldset = $this->modules->get("InputfieldFieldset");
                $csvFieldset->label = $currentData['replaceModeTitle'];
                $csvFieldset->description = $currentData['replaceModeDescription'];
                $csvFieldset->notes = $currentData['replaceModeNotes'];
                $csvFieldset->showIf = "edit_mode=replace";
                $childEditSet->add($csvFieldset);
            }

            if(in_array('paste', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldTextarea");
                $f->name = "childPagesReplace";
                $f->showIf = "edit_mode=replace";
                $f->label = __("Paste CSV");
                $f->attr('value', $this->childPages);
                $csvFieldset->append($f);
            }

            if(in_array('link', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldURL");
                $f->name = "csvUrlReplace";
                $f->showIf = "edit_mode=replace";
                $f->label = __("Enter URL to CSV file");
                $f->placeholder = __("URL to CSV file");
                $f->attr('value', '');
                $csvFieldset->append($f);
            }

            if(in_array('upload', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldMarkup");
                $f->label = __("Upload CSV file");
                $f->name = 'csvUploadReplace';
                $f->showIf = "edit_mode=replace";
                $f->value = "<input name='csvReplaceFile' type='file' />";
                $csvFieldset->add($f);
            }

        }

        // Edit
        if(in_array('edit', $currentData['editModes'])) {
            $results = $this->modules->get('InputfieldMarkup');
            $results->attr('id', 'edit');
            $results->showIf = "edit_mode=edit";
            $results->label = $currentData['editModeTitle'];
            $results->description = $currentData['editModeDescription'];
            $results->notes = $currentData['editModeNotes'];
            $table = $this->modules->get('MarkupAdminDataTable');
            $table->setSortable(true);
            $table->setEncodeEntities(false);

            //Build the table
            $rowNum=1;
            //if no children already, set up initial table row with blank name and delete button cells
            if(count($pp->children("include=all"))==0){
                $row = array(
                    "<i style='cursor:move' class='fa fa-arrows InputfieldChildTableRowSortHandle'></i>",
                    "<input id='' type='text' name='individualChildTitles[new_0]' value='' style='width:100%' />",
                    "",
                    ""
                );
                $table->row($row);
                $rowNum++;
            }
            foreach ($pp->children("include=all") as $cp) {

                if (!$cp->editable() || $cp->is(Page::statusSystemID)) continue; //Only display if current user can edit and also if it is not a system page (404, admin, trash etc)

                $row = array(
                    "<i style='cursor:move'  class='fa fa-arrows InputfieldChildTableRowSortHandle'></i>",
                    "<input id='{$cp->id}' type='text' name='individualChildTitles[{$cp->id}]' value='{$cp->title}' style='width:100%' />",
                    '<a class="childChildTableEdit" data-url="./?id='.$cp->id.'&amp;modal=1" href="#">'.$cp->name.'</a>',
                    "<i style='cursor:pointer' class='fa fa-trash-o InputfieldChildTableRowDeleteLink'></i>"
                );
                $table->row($row);
                $rowNum++;
            }

            $hiddenInfo = "<input name='idsToDelete' class='InputfieldChildTableRowDelete' type='hidden' value='' />";

            $button = $this->wire('modules')->get('InputfieldButton');
            $button->icon = 'plus-circle';
            $button->value = $this->_x('Add New', 'button');
            $button->attr('class', 'ui-button ui-widget ui-corner-all ui-state-default InputfieldChildTableAddRow');

            $results->attr('value', $hiddenInfo . '<div class="childChildTableContainer">' . $table->render() . '</div>' . $button->render());
            $childEditSet->append($results);
        }
        return $childEditSet;
    }


    public function saveChildren(HookEvent $event){

        // early exit if no edit mode has been selected
        if(!$this->input->post->edit_mode) return;

        // ProcessPageEdit's processInput function may go recursive, so we want to skip
        // the instances where it does that by checking the second argument named "level"
        $level = $event->arguments(1);
        if($level > 0) return;

        $pp = $event->object->getPage();

        //populate currentData with pageSettings version if page has specific settings
        $currentData = isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        //use the selected template or if none selected then it means there is only one childTemplate option [0], so use that
        $childTemplate = $this->input->post->childTemplate ? $this->input->post->childTemplate : $pp->template->childTemplates[0];

        //Replace Mode
        if($this->input->post->edit_mode == "replace"){

            $childPagesReplace = $this->processTextOrFile($this->input->post->childPagesReplace, $this->input->post->csvUrlReplace,'csvReplaceFile');

            //if theURL or CSV versions are empty, escape now to prevent unwanted deletion and recreation of pages
            //note that an empty textarea/paste option is valid - it provides a way to batch delete all child pages
            if($childPagesReplace == 'BCE-FILE-EMPTY') {
                $this->error($this->_("The CSV file was empty, so no pages can be created."));
                return;
            }
            //if content (textarea, URL or CSV upload) hasn't changed, escape now to prevent unwanted deletion and recreation of pages
            if($childPagesReplace == $this->childPages) return;


            if(!$currentData['disableContentProtection']){
                foreach($pp->children("include=all") as $cp){
                    if($cp->numChildren>0){
                        $this->error($this->_("You cannot bulk edit these child pages, because at least one page has a child page of its own. Try the edit option, or delete existing child pages first."));
                        return;
                    }
                    foreach($cp->fields as $cpfield){
                        if($cpfield->name != 'title' && $cp->$cpfield !=''){
                            $this->error($this->_("You cannot bulk edit these child pages, because at least one page has a field which is not empty. Try the edit option, or delete existing child pages first."));
                            return;
                        }
                    }
                }
            }
            $this->createPages($childPagesReplace, $pp, $childTemplate);
        }
        //Update Mode
        elseif($this->input->post->edit_mode == "update"){

            $childPagesUpdate = $this->processTextOrFile($this->input->post->childPagesUpdate, $this->input->post->csvUrlUpdate,'csvUpdateFile');

            //if theURL or CSV versions are empty, escape now to prevent unwanted deletion and recreation of pages
            //note that an empty textarea/paste option is valid - it provides a way to batch delete all child pages
            if($childPagesUpdate == 'BCE-FILE-EMPTY') {
                $this->error($this->_("The CSV file was empty, so no pages can be created."));
                return;
            }
            //if content (textarea, URL or CSV upload) hasn't changed, escape now to prevent unwanted deletion and recreation of pages
            if($childPagesUpdate == $this->childPages) return;


            if(!$currentData['disableContentProtection']){
                foreach($pp->children("include=all") as $cp){
                    if($cp->numChildren>0){
                        $this->error($this->_("You cannot bulk edit these child pages, because at least one page has a child page of its own. Try the edit option, or delete existing child pages first."));
                        return;
                    }
                    foreach($cp->fields as $cpfield){
                        if($cpfield->name != 'title' && $cp->$cpfield !=''){
                            $this->error($this->_("You cannot bulk edit these child pages, because at least one page has a field which is not empty. Try the edit option, or delete existing child pages first."));
                            return;
                        }
                    }
                }
            }
            $this->createPages($childPagesUpdate, $pp, $childTemplate);
        }
        //Add mode
        elseif($this->input->post->edit_mode == "add"){
            $childPagesAdd = $this->processTextOrFile($this->input->post->childPagesAdd, $this->input->post->csvUrlAdd, 'csvAddFile');
            $this->createPages($childPagesAdd, $pp, $childTemplate);
        }
        //Edit Mode
        else{
            //delete any pages marked for deletion
            if($this->input->post->idsToDelete!=''){
                $idsToDelete = explode(',', $this->input->post->idsToDelete);
                foreach($idsToDelete as $id){
                    $ptod = $this->pages->get($id);

                    if(!$currentData['disableContentProtection']){
                        if($ptod->numChildren>0){
                            $this->error($this->_("You cannot delete this child page, because it has a child page of its own. You can prevent this check by disabling Content Protection in the module config settings."));
                            return;
                        }
                        foreach($ptod->fields as $ptodfield){
                            if($ptodfield->name != 'title' && $ptod->$ptodfield !=''){
                                $this->error($this->_("You cannot delete this child page, because it has a field which is not empty. You can prevent this check by disabling Content Protection in the module config settings."));
                                return;
                            }
                        }
                    }

                    if($id!='') {
                        $currentData['trashOrDelete'] == 'delete' ? $this->pages->delete($ptod, true) : $this->pages->trash($ptod);
                    }
                }
            }

            $i=0;
            foreach($this->input->post->individualChildTitles as $id => $childTitle){
                if(isset($idsToDelete) && in_array($id, $idsToDelete)) continue; //ignore pages that have just been deleted
                $childTitle = trim($this->sanitizer->text($childTitle));
                $i++;
                if($childTitle == '') continue; // in case someone clicked add Page, but left it blank
                elseif(strpos($id, 'new') !== FALSE){
                    $cp = new Page;
                    $cp->parent = $pp;
                    $cp->template = $childTemplate;
                }
                else{
                    $cp = $this->pages->get($id);
                    //if($i==1 && !$this->input->post->childTemplate) $childTemplate = $cp->template->name; //get the template of the first child in case we need it to assign to a newly added page
                }
                $cp->title = $childTitle;
                if($this->input->post->userOverwriteNames || (!$this->input->post->userOverwriteNames && !$currentData['allowOverrideOverwriteNames'] && $currentData['overwriteNames'])){
                    $n = 0;
                    $pageName = $this->sanitizer->pageName($childTitle, Sanitizer::translate);
                    if($cp->isNew()){
                        do {
                            $name = $pageName . ($n ? "-$n" : '');
                            $child = $pp->child("name=$name"); // see if another page already has the same name
                            $n++;
                        } while($child->id);
                    }
                    else{
                        $name = $pageName;
                    }
                    $cp->name = $name;
                }
                $cp->sort = $i;

                if($cp->isChanged()) {
                    $cp->of(false);
                    $cp->save();
                }
            }
        }
    }



    public function processTextOrFile ($str, $link, $fileInputName) {

        //CSV file upload
        if(isset($_FILES[$fileInputName]['name']) && $_FILES[$fileInputName]['name'] !== ''){

            $csv_file_extension = pathinfo($_FILES[$fileInputName]["name"], PATHINFO_EXTENSION);

            if($csv_file_extension == 'csv' || $csv_file_extension == 'txt' || $csv_file_extension == 'tsv'){
                $childPagesContent = file_get_contents($_FILES[$fileInputName]["tmp_name"]);
                if($childPagesContent == '') return 'BCE-FILE-EMPTY';
            }
            else{
                $this->error($this->_("That is not an allowed file extension for a CSV import. Try again with a .csv, .tsv, or .txt file"));
            }

            unlink($_FILES[$fileInputName]["tmp_name"]);
        }
        elseif($link != '') {
            $childPagesContent = file_get_contents($link);
            if($childPagesContent == '') return 'BCE-FILE-EMPTY';
        }
        elseif($str != '') $childPagesContent = $str;
        else return;

        return mb_check_encoding($childPagesContent, 'UTF-8') ? $childPagesContent : utf8_encode($childPagesContent);
    }



    public function createPages($childPages, $pp, $childTemplate) {

        $childPages = trim(preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $childPages),"\n"); // remove any blank lines
        $childPages = str_replace("\r\n","\n", $childPages); //fix for Windows line endings
        $childPages = str_replace("\r","\n", $childPages); //fix for Mac Excel line ending issue - http://nicercode.github.io/blog/2013-04-30-excel-and-line-endings/

        //populate currentData with pageSettings version if page has specific settings
        $currentData = isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        //if defined, get field pairings
        if(isset($this->data['pageSettings'][$pp->id]['fieldPairings']) && $this->data['pageSettings'][$pp->id]['fieldPairings'] != '') {
            $convertedFieldPairings = $this->convertFieldPairings($currentData['fieldPairings']);
            //if it exists, move title to first position in array but maintain keys for pairing to CSV columns
            $titleKey = array_search('title', $convertedFieldPairings);
            if($titleKey) $convertedFieldPairings = array($titleKey => $convertedFieldPairings[$titleKey]) + $convertedFieldPairings;
        }


        $x=0;
        foreach(explode("\n",$childPages) as $childPage) {
            if($childPage == '') return;
            $i=0;
            $x++;
            if($x==1 && $currentData['ignoreFirstRow']) continue; //ignore first row which contains column names

            $row = str_getcsv($childPage, $currentData['fieldSeparator'] == "tab" ? chr(9) : $currentData['fieldSeparator'], $currentData['fieldEnclosure']);

            //if fields pairings are not defined, then make sure the field count matches the number of fields in the selected child template
            if(!isset($this->data['pageSettings'][$pp->id]['fieldPairings']) || $this->data['pageSettings'][$pp->id]['fieldPairings'] == '') {
                //only if greater than one, because one column in each row is just for setting the title/name
                if(count($row) > 1 && count($row) != count($this->templates->get($childTemplate)->fields)) {
                    $this->error($this->_("The number of columns/fields in your CSV do not match the number of fields in the template. Nothing can be safely imported. If you need to exclude certain fields, make sure the CSV has blank values for the excluded fields."));
                    return;
                }
            }
            //if field pairings are defined, check that the field/column count in the CSV is at least as many as the number of defined pairings
            //if field pairings are defined then we don't allow titles only, hence no check for count($row) > 1
            else {
                if(count($row) < count($convertedFieldPairings)) {
                    $this->error($this->_("The number of columns/fields in your CSV is not enough for number of fields defined for this import. Nothing can be safely imported."));
                    return;
                }
            }

            //if first loop and replace mode then now it's safe to delete all existing child pages because above checks for field pairings have passed
            if(($x==1 || ($x==2 && $currentData['ignoreFirstRow'])) && $this->input->post->edit_mode == "replace") {
                foreach($pp->children("include=all") as $cp) {
                    if(!$cp->is(Page::statusSystemID)) {
                        $currentData['trashOrDelete'] == 'delete' ? $this->pages->delete($cp, true) : $this->pages->trash($cp);
                    }
                }
            }

            //create new or edit existing child pages

            //if fieldPairings is defined and this is first column, then set name/title and create new / get existing page
            if($i==0 && $currentData['fieldPairings'] != '') {
                // if title key exists, then make sure it is populated
                // not necessary in update mode only setups so it may be not set
                if($titleKey && $row[$titleKey-1] == '') continue;
                //update mode so re-title/re-name existing page
                if($this->input->post->edit_mode == "update") {
                    $np = $pp->children->eq($currentData['ignoreFirstRow'] ? $x-2 : $x-1);
                    if($this->input->post->userOverwriteNames || (!$this->input->post->userOverwriteNames && !$currentData['allowOverrideOverwriteNames'] && $currentData['overwriteNames'])){
                        if($titleKey) $np->name = trim($this->sanitizer->pageName($row[$titleKey-1], Sanitizer::translate));
                    }
                }
                //not update mode, so create new page
                else {
                    $np = new Page();
                    $np->parent = $pp;
                    $np->template = $childTemplate;
                }

                if($titleKey) $np->title = trim($this->sanitizer->text($row[$titleKey-1]));
                $np->of(false);
                $np->save();
            }

            //creating pages and populating fields
            foreach($row as $childField) {
                $childField = trim($this->sanitizer->text($childField));
                //if fieldPairings is defined now populate the rest of the fields
                if($currentData['fieldPairings'] != '') {
                    //populate new page with rest of the field values
                    if(isset($convertedFieldPairings[$i+1]) && $convertedFieldPairings[$i+1] !== 'title') { // no need to redefine the title field value
                        $np->$convertedFieldPairings[$i+1] = $childField;
                        $np->save($convertedFieldPairings[$i+1]);
                    }
                }
                // else field pairings not defined, so match all fields in order
                else {
                    //first item is the page title so create new page
                    if($i==0) {
                        if($childField == '') continue;
                        //update mode so re-title/re-name existing page
                        if($this->input->post->edit_mode == "update") {
                            $np = $pp->children->eq($currentData['ignoreFirstRow'] ? $x-2 : $x-1);
                            if($this->input->post->userOverwriteNames || (!$this->input->post->userOverwriteNames && !$currentData['allowOverrideOverwriteNames'] && $currentData['overwriteNames'])){
                                $np->name = trim($this->sanitizer->pageName($childField, Sanitizer::translate));
                            }
                        }
                        //not update mode, so create new page
                        else {
                            $np = new Page();
                            $np->parent = $pp;
                            $np->template = $childTemplate;
                        }
                        $np->title = trim($this->sanitizer->text($childField));
                        $np->of(false);
                        $np->save();

                        //populate numeric array of field names
                        $fieldsArray = array();
                        foreach($np->fields as $f) $fieldsArray[] = $f->name;
                    }
                    //populate new page with rest of the field values
                    else {
                        $np->$fieldsArray[$i] = $childField;
                        $np->save($fieldsArray[$i]);
                    }
                }
                $i++;
            }
        }
    }


    /**
     * Return an InputfieldsWrapper of Inputfields used to configure the class
     *
     * @param array $data Array of config values indexed by field name
     * @return InputfieldsWrapper
     *
     */
    public static function getModuleConfigInputfields(array $data) {

        $data = array_merge(self::getDefaultData(), $data);

        $wrapper = new InputFieldWrapper();

        $fieldEnabledTemplates = wire('modules')->get('InputfieldAsmSelect');
        $fieldEnabledTemplates->attr('name+id', 'enabledTemplates');
        $fieldEnabledTemplates->label = __('Enabled templates', __FILE__);
        $fieldEnabledTemplates->columnWidth = 33;
        $fieldEnabledTemplates->description = __("The batch editing option will only be available for the selected templates.\nNB Leave blank to allow all templates.", __FILE__);
        $fieldEnabledTemplates->setAsmSelectOption('sortable', false);

        // populate with all available templates
        foreach(wire('templates') as $t) {
            // filter out system templates
            if(!($t->flags & Template::flagSystem)) $fieldEnabledTemplates->addOption($t->name);
        }
        if(isset($data['enabledTemplates'])) $fieldEnabledTemplates->value = $data['enabledTemplates'];
        $wrapper->add($fieldEnabledTemplates);


        $fieldEnabledPages = wire('modules')->get('InputfieldPageListSelectMultiple');
        $fieldEnabledPages->attr('name+id', 'enabledPages');
        $fieldEnabledPages->label = __('Enabled pages', __FILE__);
        $fieldEnabledPages->columnWidth = 34;
        $fieldEnabledPages->description = __("The batch editing option will only be available for the selected pages.\nNB Leave blank to allow all pages.", __FILE__);
        $fieldEnabledPages->attr('title', __('Enable page', __FILE__));
        if(isset($data['enabledPages'])) $fieldEnabledPages->value = $data['enabledPages'];
        $wrapper->add($fieldEnabledPages);

        $fieldConfigurablePages = wire('modules')->get('InputfieldPageListSelectMultiple');
        $fieldConfigurablePages->attr('name+id', 'configurablePages');
        $fieldConfigurablePages->label = __('Configurable pages', __FILE__);
        $fieldConfigurablePages->columnWidth = 33;
        $fieldConfigurablePages->description = __("Selected pages will have their own config settings for Batch Child Editor - these will be added to the page's Settings tab. All other pages will use the config settings below.", __FILE__);
        $fieldConfigurablePages->attr('title', __('Enable page', __FILE__));
        if(isset($data['configurablePages'])) $fieldConfigurablePages->value = $data['configurablePages'];
        $wrapper->add($fieldConfigurablePages);

        buildCoreSettings($data, $wrapper);

        return $wrapper;
    }


    public function convertFieldPairings ($fieldPairings) {
        //convert to array of column numbers and PW field names
        $temp = explode("\r\n", $fieldPairings);
        $convertedFieldPairings = array();
        foreach ($temp as $value) {
            $array = explode(':', str_replace(' ', '', $value));
            $array[1] = trim($array[1], '"');
            $convertedFieldPairings[$array[0]] = $array[1];
        }
        return $convertedFieldPairings;
    }


    /**
     * Called only when your module is installed
     *
     * Create a new permission.
     *
     */
    public function ___install() {
        $permission = $this->permissions->get('batch-child-editor');
        if (!$permission->id) {
            $p = new Permission();
            $p->name = 'batch-child-editor';
            $p->title = $this->_('Use Batch Child Editor');
            $p->save();
            // tell the user we created this module's permission
            $this->message($this->_("Created New Permission: batch-child-editor"));
            $this->message($this->_("Assigned batch-child-editor permission to superuser"));
        }

        $su = $this->roles->get("superuser");
        $su->addPermission("batch-child-editor");
        $su->save();
    }

    /**
     * Called only when your module is uninstalled
     *
     * Remove the special permission
     *
     */
    public function ___uninstall() {
        $permission = $this->permissions->get('batch-child-editor');
        if ($permission->id) {
            $permission->delete();
            $this->message($this->_("Deleted Permission: batch-child-editor"));
        }
    }

}


function buildCoreSettings ($data, $wrapper, $pid = null) {
    $f = wire('modules')->get("InputfieldCheckboxes");
    $f->attr('name', 'editModes');
    $f->label = __('Edit Modes');
    $f->required = true;
    $f->columnWidth = 25;
    $f->description = __('Which edit modes you want available. If more than one checked, then the user can decide.');
    $f->addOption("edit","Edit");
    $f->addOption("add","Add");
    $f->addOption("update","Update");
    $f->addOption("replace","Replace");
    $f->value = $pid && isset($data['pageSettings'][$pid]['editModes']) ? $data['pageSettings'][$pid]['editModes'] : $data['editModes'];
    $f->notes = __("The Edit and Add modes are safer than the Update and Replace modes, because they are non-destructive.\n\nUpdate will edit the content of fields of existing pages. Replace will delete all child pages and create new ones.");
    $wrapper->add($f);


    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'overwriteNames');
    $f->label = __('Overwrite names');
    $f->showIf = "editModes=edit|update";
    $f->columnWidth = 25;
    $f->description = __('Whether to overwrite the name of the page, and not just the title.');
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]['overwriteNames']) ? $data['pageSettings'][$pid]['overwriteNames'] : $data['overwriteNames']) ? 'checked' : '' );
    $f->notes = __("Only relevant for Edit and Update modes. This option can cause problems if the affected child pages are part of the front end structure of the site. It may result in broken links, etc.");
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'allowOverrideOverwriteNames');
    $f->label = __('Allow user to change "Overwrite Names" setting');
    $f->showIf = "editModes=edit|update";
    $f->columnWidth = 25;
    $f->description = __('Whether an admin user can change the override option when doing a batch edit.');
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]['allowOverrideOverwriteNames']) ? $data['pageSettings'][$pid]['allowOverrideOverwriteNames'] : $data['allowOverrideOverwriteNames']) ? 'checked' : '' );
    $f->notes = __("Only relevant for Edit and Update modes.");
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'disableContentProtection');
    $f->label = __('Disable Content Protection');
    $f->showIf = "editModes=replace|edit";
    $f->columnWidth = 25;
    $f->description = __('If checked, replace mode will destructively replace children even if they have additional field content and grandchildren. It also allows deletion of pages in edit mode that have their own children.');
    $f->notes = __("This can be extremely destructive, use with extreme caution!");
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]['disableContentProtection']) ? $data['pageSettings'][$pid]['disableContentProtection'] : $data['disableContentProtection']) ? 'checked' : '' );
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldCheckboxes");
    $f->attr('name', 'csvOptions');
    $f->label = __('Page Titles / CSV Options');
    $f->showIf = "editModes=add|update|replace";
    $f->required = true;
    $f->requiredIf = "editModes=add|update|replace";
    $f->columnWidth = 40;
    $f->description = __('Which page entry options do you want available.');
    $f->notes = __("For creating page title/names only, then Text/Paste is likely the most relevant option. CSV options to the right only relevant if populating other page fields in addition to the title/name.");
    $f->addOption("paste","Text/Paste");
    $f->addOption("link","Link (URL)");
    $f->addOption("upload","Upload");
    $f->value = $pid && isset($data['pageSettings'][$pid]['csvOptions']) ? $data['pageSettings'][$pid]['csvOptions'] : $data['csvOptions'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->name = 'fieldSeparator';
    $f->label = __('CSV Fields separated with');
    $f->showIf = "editModes=add|update|replace";
    $f->notes = __('For tab separated, enter: tab');
    $f->value = $pid && isset($data['pageSettings'][$pid]['fieldSeparator']) ? $data['pageSettings'][$pid]['fieldSeparator'] : $data['fieldSeparator'];
    $f->columnWidth = 20;
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->name = 'fieldEnclosure';
    $f->label = __('CSV Field enclosure');
    $f->showIf = "editModes=add|update|replace";
    $f->value = $pid && isset($data['pageSettings'][$pid]['fieldEnclosure']) ? $data['pageSettings'][$pid]['fieldEnclosure'] : $data['fieldEnclosure'];
    $f->columnWidth = 20;
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->name = 'ignoreFirstRow';
    $f->label = __('CSV Ignore the first row');
    $f->showIf = "editModes=add|update|replace";
    $f->notes = __('Use this if the first row is field names');
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]['ignoreFirstRow']) ? $data['pageSettings'][$pid]['ignoreFirstRow'] : $data['ignoreFirstRow']) ? 'checked' : '' );
    $f->columnWidth = 20;
    $wrapper->add($f);

    //only for page context settings
    if(wire('input')->get->id) {
        $f = wire('modules')->get("InputfieldTextarea");
        $f->name = 'fieldPairings';
        $f->label = __('CSV Field Pairings');
        $f->description = __("Enter CSV column number and Processwire field name pairs to match up when importing. If empty, all CSV columns will be imported in order and therefore must match the number of fields in the template for this page.");
        $f->notes = __("Column numbers start at 1 so in this example we are excluding the 3rd column in the CSV file:\n1:title\n2:body\n4:notes\n\nNB Unless the only edit mode is \"Update\", you must include at least the title field, but all other fields are optional.");
        $f->showIf = "editModes=add|update|replace";
        $f->value = isset($data['pageSettings'][$pid]['fieldPairings']) ? $data['pageSettings'][$pid]['fieldPairings'] : '';
        $wrapper->add($f);
    }

    $f = wire('modules')->get("InputfieldRadios");
    $f->attr('name', 'trashOrDelete');
    $f->label = __('Trash or Delete');
    $f->columnWidth = 25;
    $f->description = __('Whether you want deleted pages moved to the trash or permanently deleted.');
    $f->addOption("trash","Trash");
    $f->addOption("delete","Delete");
    $f->value = $pid && isset($data['pageSettings'][$pid]['trashOrDelete']) ? $data['pageSettings'][$pid]['trashOrDelete'] : $data['trashOrDelete'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldRadios");
    $f->attr('name', 'position');
    $f->label = __('Position');
    $f->columnWidth = 25;
    $f->description = __('Where to position the Batch Child Editor tool. Replace will remove the existing page tree. New Tab will put this editor in a new tab.');
    $f->addOption("top","Top");
    $f->addOption("bottom","Bottom");
    $f->addOption("replace","Replace");
    $f->addOption("newTab","New Tab");
    $f->value = $pid && isset($data['pageSettings'][$pid]['position']) ? $data['pageSettings'][$pid]['position'] : $data['position'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'loadOpen');
    $f->label = __('Load Open, not Collapsed');
    $f->showIf = "position!=newTab";
    $f->columnWidth = 25;
    $f->description = __('If checked, batch child editor will initially be open, not collapsed.');
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]['loadOpen']) ? $data['pageSettings'][$pid]['loadOpen'] : $data['loadOpen']) ? 'checked' : '' );
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'tabName');
    $f->label = __('Tab Name');
    $f->showIf = "position=newTab";
    $f->required = 1;
    $f->requiredIf = "position=newTab";
    $f->columnWidth = 25;
    $f->description = __('Name for the new tab.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['tabName']) ? $data['pageSettings'][$pid]['tabName'] : $data['tabName'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'editModeTitle');
    $f->label = __('Edit Mode Title');
    $f->showIf = "editModes=edit";
    $f->columnWidth = 33;
    $f->description = __('Custom title in Edit mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['editModeTitle']) ? $data['pageSettings'][$pid]['editModeTitle'] : $data['editModeTitle'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'editModeDescription');
    $f->label = __('Edit Mode Description');
    $f->showIf = "editModes=edit";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Edit mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['editModeDescription']) ? $data['pageSettings'][$pid]['editModeDescription'] : $data['editModeDescription'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'editModeNotes');
    $f->label = __('Edit Mode Notes');
    $f->showIf = "editModes=edit";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Edit mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['editModeNotes']) ? $data['pageSettings'][$pid]['editModeNotes'] : $data['editModeNotes'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'addModeTitle');
    $f->label = __('Add Mode Title');
    $f->showIf = "editModes=add";
    $f->columnWidth = 33;
    $f->description = __('Custom title for Add mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['addModeTitle']) ? $data['pageSettings'][$pid]['addModeTitle'] : $data['addModeTitle'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'addModeDescription');
    $f->label = __('Add Mode Description');
    $f->showIf = "editModes=add";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Add mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['addModeDescription']) ? $data['pageSettings'][$pid]['addModeDescription'] : $data['addModeDescription'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'addModeNotes');
    $f->label = __('Add Mode Notes');
    $f->showIf = "editModes=add";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Add mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['addModeNotes']) ? $data['pageSettings'][$pid]['addModeNotes'] : $data['addModeNotes'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'updateModeTitle');
    $f->label = __('Update Mode Title');
    $f->showIf = "editModes=update";
    $f->columnWidth = 33;
    $f->description = __('Custom title for Update mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['updateModeTitle']) ? $data['pageSettings'][$pid]['updateModeTitle'] : $data['updateModeTitle'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'updateModeDescription');
    $f->label = __('Update Mode Description');
    $f->showIf = "editModes=update";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Update mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['updateModeDescription']) ? $data['pageSettings'][$pid]['updateModeDescription'] : $data['updateModeDescription'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'updateModeNotes');
    $f->label = __('Update Mode Notes');
    $f->showIf = "editModes=update";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Add mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['updateModeNotes']) ? $data['pageSettings'][$pid]['updateModeNotes'] : $data['updateModeNotes'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'replaceModeTitle');
    $f->label = __('Replace Mode Title');
    $f->showIf = "editModes=replace";
    $f->columnWidth = 33;
    $f->description = __('Custom title for Replace mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['replaceModeTitle']) ? $data['pageSettings'][$pid]['replaceModeTitle'] : $data['replaceModeTitle'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'replaceModeDescription');
    $f->label = __('Replace Mode Description');
    $f->showIf = "editModes=replace";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Replace mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['replaceModeDescription']) ? $data['pageSettings'][$pid]['replaceModeDescription'] : $data['replaceModeDescription'];
    $wrapper->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'replaceModeNotes');
    $f->label = __('Replace Mode Notes');
    $f->showIf = "editModes=replace";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Add mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]['replaceModeNotes']) ? $data['pageSettings'][$pid]['replaceModeNotes'] : $data['replaceModeNotes'];
    $wrapper->add($f);
}