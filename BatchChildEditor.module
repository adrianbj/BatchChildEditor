<?php

/**
 * ProcessWire batch creation (titles only or CSV import for other fields), editing, sorting, deletion, and CSV export of all children under a given page.
 * by Adrian Jones
 *
 * ProcessWire 2.x
 * Copyright (C) 2011 by Ryan Cramer
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 *
 * http://www.processwire.com
 * http://www.ryancramer.com
 *
 */

class BatchChildEditor extends WireData implements Module, ConfigurableModule {

    public static function getModuleInfo() {
        return array(
            'title' => 'Batch child editor',
            'summary' => 'Quick batch creation (titles only or CSV import for other fields), editing, sorting, deletion, and CSV export of all children under a given page.',
            'href' => 'http://modules.processwire.com/modules/batch-child-editor/',
            'version' => 87,
            'permanent' => false,
            'autoload' => true,
            'requires' => 'ProcessWire>=2.5.24',
            'installs' => 'ProcessChildrenCsvExport',
            'icon'     => 'child'
        );
    }


    /**
     * Data as used by the get/set functions
     *
     */
    protected $data = array();
    protected $childPages = '';

   /**
     * Default configuration for module
     *
     */
    static public function getDefaultData() {
            return array(
                "systemFields" => array(
                    'id' => __('ID'),
                    'name' => __('Name (from URL)'),
                    'path' => __('Path'),
                    'url' => __('URL'),
                    'status' => __('Status'),
                    'created' => __('Date Created'),
                    'modified' => __('Date Last Modified'),
                    'createdUser.id' => __('Created by User: ID'),
                    'createdUser.name' => __('Created by User: Name'),
                    'modifiedUser.id' => __('Modified by User: ID'),
                    'modifiedUser.name' => __('Modified by User: Name'),
                    'parent_id' => __('Parent Page ID'),
                    'parent.name' => __('Parent Page Name'),
                    'template.id' => __('Template ID'),
                    'template' => __('Template Name')
                ),
                "enabledTemplates" => array(),
                "enabledPages" => array(),
                "configurablePages" => array(),
                "editModes" => array("edit"),
                "defaultMode" => "",
                "overwriteNames" => "",
                "allowOverrideOverwriteNames" => "",
                "loadOpen" => "",
                "csvOptions" => array(),
                "csvOptionsCollapsed" => array(),
                "csvImportFieldSeparator" => ",",
                "csvImportFieldEnclosure" => '"',
                "multipleValuesSeparator" => "|",
                "ignoreFirstRow" => "",
                "exportFields" => "",
                "csvExportFieldSeparator" => ",",
                "csvExportFieldEnclosure" => '"',
                "csvExportExtension" => 'csv',
                "columnsFirstRow" => "",
                "allowOverrideCsvImportSettings" => "",
                "allowOverrideCsvExportSettings" => "",
                "fieldPairings" => "",
                "trashOrDelete" => "trash",
                "position" => "bottom",
                "tabName" => "Batch Child Editor",
                "disableContentProtection" => "",
                "allowTemplateChanges" => "",
                "editModeTitle" => "Edit Child Pages",
                "editModeDescription" => "You can edit the page titles, sort, delete, add new, or edit pages in a modal popup.",
                "editModeNotes" => "",
                "addModeTitle" => "Add Child Pages",
                "addModeDescription" => "Editing this field will add all the child page titles listed here to the existing set of child pages.",
                "addModeNotes" => "Each row is a separate page.\n\nYou can also use CSV formatted lines for populating all text/numeric fields on the page, eg:\n\"Bolivia, Plurinational State of\",BO,\"BOLIVIA, PLURINATIONAL STATE OF\",BOL,68",
                "updateModeTitle" => "Update Child Pages",
                "updateModeDescription" => "Editing this field will update the field values of the pages represented here.",
                "updateModeNotes" => "WARNING: If you use this option, the content of all fields in existing pages will be replaced.\n\nEach row is a separate page.\n\nYou can also use CSV formatted lines for populating all text/numeric fields on the page, eg:\n\"Bolivia, Plurinational State of\",BO,\"BOLIVIA, PLURINATIONAL STATE OF\",BOL,68",
                "replaceModeTitle" => "Replace Child Pages",
                "replaceModeDescription" => "Editing this field will replace all the child page titles represented here.",
                "replaceModeNotes" => "WARNING: If you use this option, all the existing child pages (and grandchildren) will be deleted and new ones created.\n\nEach row is a separate page.\n\nYou can also use CSV formatted lines for populating all text/numeric fields on the page, eg:\n\"Bolivia, Plurinational State of\",BO,\"BOLIVIA, PLURINATIONAL STATE OF\",BOL,68",
                "exportModeTitle" => "Export Child Pages",
                "exportModeDescription" => "Creates a CSV file with one row for each child page.",
                "exportModeNotes" => "",
                "pageSettings" => array(),
            );
    }

    /**
     * Populate the default config data
     *
     */
    public function __construct() {
       foreach(self::getDefaultData() as $key => $value) {
               $this->$key = $value;
       }
    }


    public function init() {
        $this->addHookAfter("ProcessPageEdit::buildFormChildren", $this, "addScript");
    }

    public function addScript($event){
        $conf = $this->getModuleInfo();
        $version = (int) $conf['version'];
         wire("config")->scripts->add($this->config->urls->BatchChildEditor . "BatchChildEditor.js?v={$version}");
    }

    public function ready() {

        if(!$this->user->hasPermission("batch-child-editor")) return;

        // we're interested in page editor only
        if(wire('page')->process != 'ProcessPageEdit') return;

        $id = (int)$this->input->get->id;
        if(!$id) return;

        //populate currentData with pageSettings version if page has specific settings
        $currentData = in_array($id, $this->data['configurablePages']) && isset($this->data['pageSettings'][$id]) && $this->data['pageSettings'][$id] ? $this->data['pageSettings'][$id] : $this->data;

        // GET parameter id tells the page that's being edited
        $this->editedPage = wire('pages')->get($id);

        // don't even consider system templates
        if($this->editedPage->template->flags & Template::flagSystem) return;

        // if any templates or pages have been selected, then only hook if the template of the edited page has been chosen or the page has been chosen
        //if(count($this->data['enabledTemplates']) === 0 && count($this->data['enabledPages']) === 0) return;
        if(count($this->data['enabledTemplates']) !== 0 && !in_array($this->editedPage->template->name, $this->data['enabledTemplates'])) return;
        if(count($this->data['enabledPages']) !== 0 && !in_array($this->editedPage->id, $this->data['enabledPages'])) return;

        //Make sure at least one edit mode has been selected in the config
        if(count($currentData['editModes']) == 0) return;

        //if position is "new tab" we also need to check that the template family settings allow the page to have children
        if($currentData['position'] == 'newTab' && !$this->editedPage->template->noChildren) {
            $this->addHookAfter('ProcessPageEdit::buildFormContent', $this, 'addNewTab');
        }
        else {
            $this->addHookAfter('ProcessPageEdit::buildFormChildren', $this, 'addChildEditFieldset');
        }
        $this->addHookAfter('ProcessPageEdit::processInput', $this, 'saveChildren');

        // page specific config settings
        if($this->user->isSuperuser() && count($this->data['configurablePages']) !== 0 && in_array($this->editedPage->id, $this->data['configurablePages'])) {
            $this->addHookAfter('ProcessPageEdit::buildFormSettings', $this, 'buildPageConfigForm');
            $this->addHookAfter('ProcessPageEdit::processInput', $this, 'processPageConfigForm');
        }

    }



    public function buildPageConfigForm(HookEvent $event){

        $pp = $event->object->getPage();

        $inputfields = $event->return;

        $fieldset = $this->modules->get("InputfieldFieldset");
        $fieldset->attr('id', 'batch_child_editor_config_fieldset');
        $fieldset->label = __("Batch Child Editor Settings");
        if(!isset($this->data['pageSettings'][$pp->id])) $fieldset->collapsed = Inputfield::collapsedYes;

        $f = wire('modules')->get("InputfieldMarkup");
        $f->attr('name', 'config_intro');
        $f->label = "";
        $f->value = "<p>These settings will override those in the main config settings for this page.</p>";
        $fieldset->append($f);

        buildCoreSettings($this->data, $fieldset, $pp->id);

        $inputfields->append($fieldset);


        // check integrity of field pairings list
        if(isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id]) {
            if($this->data['pageSettings'][$pp->id]['fieldPairings'] != '') {
                $convertedFieldPairings = $this->convertFieldPairings($this->data['pageSettings'][$pp->id]['fieldPairings']);
                // if field pairings are set, make sure a title field is defined
                // maybe we want to make this optional at some point in case template doesn't actually have/require a title field
                if(!in_array('title', $convertedFieldPairings)) {
                    if(in_array('add', $this->data['pageSettings'][$pp->id]['editModes']) || in_array('replace', $this->data['pageSettings'][$pp->id]['editModes'])) {
                        $this->error($this->_("You must include a \"title\" field in the CSV Field Pairings, unless the only available modes are \"Edit\" and \"Update\"."));
                    }
                }

                // make sure all the fields exist in the templates that are possible for child pages
                $possibleTemplates = array();
                if(count($pp->template->childTemplates)==0){
                    foreach($this->templates as $t) {
                        if(!($t->flags & Template::flagSystem)) $possibleTemplates[] = $t->name;
                    }
                }
                else{
                    foreach($pp->template->childTemplates as $t) {
                        $possibleTemplates[] = $this->templates->get($t)->name;
                    }
                }
                $missingFields = array();
                $availableFields = array();
                foreach($possibleTemplates as $t) {
                    foreach($convertedFieldPairings as $f) {
                        //check for subfields with period (.) separator and extract parent field name
                        if (strpos($f,'.')) {
                            $fieldParts = explode('.', $f);
                            $f = $fieldParts[0];
                        }
                        if($this->templates->get($t)->hasField($f)) {
                            if(!in_array($f, $availableFields)) $availableFields[] = $f;
                        }
                        else{
                            if(!in_array($f, $missingFields)) $missingFields[] = $f;
                        }
                    }
                }
                foreach($availableFields as $af) {
                    if(($key = array_search($af, $missingFields)) !== false) {
                        unset($missingFields[$key]);
                    }
                }
                if(!empty($missingFields)) $this->error($this->_("The following fields defined in \"Field Pairings\" are not available in any of the allowed templates for child pages: " . implode(', ', $missingFields)));
            }
        }
    }



    public function processPageConfigForm(HookEvent $event){

        // ProcessPageEdit's processInput function may go recursive, so we want to skip
        // the instances where it does that by checking the second argument named "level"
        $level = $event->arguments(1);
        if($level > 0) return;

        $p = $event->object->getPage();

        $options = array("pid" => $p->id);
        foreach(self::getDefaultData() as $key => $value) {
            $options[$key] = $this->input->post->$key;
        }
        $this->saveSettings($options);
    }


    public function saveSettings($options) {
        $pid = $options['pid'];
        unset($this->data['pageSettings'][$pid]); // remove existing record for this page - need a clear slate for adding new settings or if it was just disabled
        foreach($options as $key => $value) {
            $this->data['pageSettings'][$pid][$key] = $value;
        }

        // save to config data with the rest of the settings
        $this->modules->saveModuleConfigData($this->modules->get("BatchChildEditor"), $this->data);
    }


    public function addChildEditFieldset(HookEvent $event){

        $pp = $event->object->getPage();
        $form = $event->return;

        //populate currentData with pageSettings version if page has specific settings
        $currentData = in_array($pp->id, $this->data['configurablePages']) && isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        $childEditSet = $this->createChildEditSet($pp, $form);

        if($currentData['position'] == 'top') $form->prepend($childEditSet);
        elseif ($currentData['position'] == 'replace') {
            foreach($form as $field) {
                if($field->label == 'Children / Subpages') $form->remove($field);
            }
            $form->prepend($childEditSet);
        }
        else $form->append($childEditSet); // bottom
    }


    public function addNewTab(HookEvent $event){

        $pp = $event->object->getPage();
        $form = $event->return;

        //populate currentData with pageSettings version if page has specific settings
        $currentData = in_array($pp->id, $this->data['configurablePages']) && isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        //build the content of the tab
        $childEditSet = $this->createChildEditSet($pp, $form);

        //old approach - works, but prevents being able to position the tab anywhere but after the View tab
        //if going back to this approach, then need to change the hook that calls this method to ProcessPageEdit::buildForm
        /*
        // create the tab
        $newTab = new InputfieldWrapper();
        $newTab->attr('id', $this->className() . $this->sanitizer->pageName($currentData['tabName'],true));
        $newTab->attr('title', $currentData['tabName']);
        $newTab->prepend($childEditSet);
        $form->prepend($newTab); // this prepend is putting the childeditset before the save button, although I really want to change the order of the tab itself to just after Content
        */

        $this->modules->get('FieldtypeFieldsetTabOpen');
        $field = new InputfieldFieldsetTabOpen;
        $field->name = $this->sanitizer->pageName($currentData['tabName'],true);
        $field->label = $currentData['tabName'];
        $form->add($field);

        $form->add($childEditSet);

        $this->modules->get('FieldtypeFieldsetClose');
        $field = new InputfieldFieldsetClose;
        $field->name = $this->sanitizer->pageName($currentData['tabName'],true)."_END";
        $form->add($field);
    }


    public function createChildEditSet($pp, $form) {

        //populate currentData with pageSettings version if page has specific settings
        $currentData = in_array($pp->id, $this->data['configurablePages']) && isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        //get user CSV setting overrides if allowed
        if(isset($currentData['allowOverrideCsvImportSettings']) && $currentData['allowOverrideCsvImportSettings']) {

            $fieldSeparator = $currentData['csvImportFieldSeparator'];
            $fieldEnclosure = $currentData['csvImportFieldEnclosure'];
            $ignoreFirstRow = $currentData['ignoreFirstRow'];

            if($this->session->userCsvImportFieldSeparator) $currentData['csvImportFieldSeparator'] = $this->session->userCsvImportFieldSeparator;
            if($this->session->userCsvImportFieldEnclosure) $currentData['csvImportFieldEnclosure'] = $this->session->userCsvImportFieldEnclosure;
            if($this->session->userIgnoreFirstRow) $currentData['ignoreFirstRow'] = $this->session->userIgnoreFirstRow;
        }

        foreach($pp->children("include=all") as $cp) {
            if(!$cp->is(Page::statusSystemID)) $this->childPages .= "{$cp->title}\r\n";
        }
        $this->childPages = rtrim($this->childPages, "\r\n");
        if($currentData['ignoreFirstRow']) $this->childPages = "Title\r\n".$this->childPages;

        // create the fieldset
        $childEditSet = $this->modules->get("InputfieldFieldset");
        $childEditSet->attr('name', 'child_batch_editor');
        $childEditSet->collapsed = $currentData['loadOpen'] ? '' : Inputfield::collapsedYes;
        $childEditSet->label = $currentData['position'] == 'newTab' ? ' ' : $childEditSet->label = __('Batch Editor / Creator');

        if(count($currentData['editModes'])>1){
            $f = $this->modules->get("InputfieldRadios");
            $f->attr('name', 'edit_mode');
            $f->label = __('Mode');
            if(!$currentData['allowOverrideOverwriteNames'] && (is_array($pp->template->childTemplates) && count($pp->template->childTemplates)==1)) $f->optionColumns = 1;
            $f->columnWidth = 33;
            foreach($currentData['editModes'] as $editMode){
                if($editMode == 'update' && $pp->children->count == 0) continue;
                //check users add rights for add and replace mode
                if(($editMode == 'add' || $editMode == 'replace') && !$pp->addable()) continue;
                $f->addOption($editMode, ucfirst($editMode));
            }
            if($this->input->get->s && $this->session->edit_mode) {
                $f->value = $this->session->edit_mode;
            }
            else {
                if($currentData['defaultMode']) $f->value = $currentData['defaultMode'];
            }
            $childEditSet->add($f);
        }
        else{
            $f = $this->modules->get("InputfieldHidden");
            $f->attr('name', 'edit_mode');
            $f->value = $currentData['editModes'][0];
            $childEditSet->add($f);
        }

        if(is_array($pp->template->childTemplates) && count($pp->template->childTemplates)!=1){
            $f = $this->modules->get("InputfieldSelect");
            $f->required = true;
            $f->name = "childTemplate";
            $f->showIf = "edit_mode.count>0, edit_mode!=export, edit_mode!=edit";
            $f->label = __('Child Template');
            $f->columnWidth = 34;
            $f->description = __('Choose the template for new children');
            /*if(count($pp->template->childTemplates)==0){
                foreach($this->templates as $t) {
                    if(!($t->flags & Template::flagSystem)) $f->addOption($t->name);
                }
            }
            else{
                $f->addOption('');
                foreach($pp->template->childTemplates as $t) {
                    $f->addOption($this->templates->get($t)->name);
                }
            }*/
            foreach($this->templates as $t) {
                if(!$this->isAllowedTemplateAdd($t, $pp)) continue;
                $f->addOption($this->templates->get($t)->name);
            }
            if($pp->children("include=all")->count()>0 && $pp->children("include=all")->last()->id) $f->attr('value', $pp->children("include=all")->last()->template);
            $childEditSet->add($f);
        }

        if($currentData['allowOverrideOverwriteNames']){
            $f = wire('modules')->get("InputfieldCheckbox");
            $f->attr('name', 'userOverwriteNames');
            $f->showIf = "edit_mode=edit|update";
            $f->label = __('Overwrite names');
            $f->columnWidth = 33;
            $f->description = __('Whether to overwrite the name of the page, and not just the title.');
            $f->attr('checked', $currentData['overwriteNames'] ? 'checked' : '' );
            $f->notes = __("This option can cause problems if the affected child pages are part of the front end structure of the site. It may result in broken links, etc.");
            $childEditSet->add($f);
        }

        // User CSV Import Settings
        if((isset($currentData['allowOverrideCsvImportSettings']) && $currentData['allowOverrideCsvImportSettings']) && (in_array('add', $currentData['editModes']) || in_array('update', $currentData['editModes']) || in_array('replace', $currentData['editModes']))) {

            $csvSettingsFieldset = $this->modules->get("InputfieldFieldset");
            $csvSettingsFieldset->label = __("CSV Import Settings");
            $csvSettingsFieldset->showIf = "edit_mode=add|update|replace";
            //if all CSV settings are the same as defaults (page or module level), then collapse
            if($fieldSeparator == $currentData['csvImportFieldSeparator'] && $fieldEnclosure == $currentData['csvImportFieldEnclosure'] && $ignoreFirstRow == $currentData['ignoreFirstRow']) $csvSettingsFieldset->collapsed = Inputfield::collapsedYes;
            $childEditSet->add($csvSettingsFieldset);

            $f = wire('modules')->get("InputfieldText");
            $f->name = 'userCsvImportFieldSeparator';
            $f->label = __('CSV fields separated with');
            $f->showIf = "edit_mode=add|update|replace";
            $f->notes = __('For tab separated, enter: tab');
            $f->value = $this->session->userCsvImportFieldSeparator ? $this->session->userCsvImportFieldSeparator : $currentData['csvImportFieldSeparator'];
            $f->columnWidth = 33;
            $csvSettingsFieldset->append($f);

            $f = wire('modules')->get("InputfieldText");
            $f->name = 'userCsvImportFieldEnclosure';
            $f->label = __('CSV field enclosure');
            $f->showIf = "edit_mode=add|update|replace";
            $f->value = $this->session->userCsvImportFieldEnclosure ? $this->session->userCsvImportFieldEnclosure : $currentData['csvImportFieldEnclosure'];
            $f->columnWidth = 34;
            $csvSettingsFieldset->append($f);

            $f = wire('modules')->get("InputfieldCheckbox");
            $f->attr('name', 'userIgnoreFirstRow');
            $f->label = __('CSV ignore the first row');
            $f->description = __('Use this if the first row contains column/field labels.');
            $f->showIf = "edit_mode=add|update|replace";
            //using $this->session->userCsvImportFieldSeparator in the ternary conditional because when $this->session->userIgnoreFirstRow is not "1", it doesn't seem to exist, even with isset!
            //this is fine, because once page has been saved, with any of these overrides, we have values for all in the session variable
            $f->attr('checked', ($this->session->userCsvImportFieldSeparator ? $this->session->userIgnoreFirstRow : $currentData['ignoreFirstRow']) ? 'checked' : '' );
            $f->columnWidth = 33;
            $csvSettingsFieldset->append($f);
        }

        // Add
        if(in_array('add', $currentData['editModes'])) {

            $csvFieldset = $this->modules->get("InputfieldFieldset");
            $csvFieldset->label = $currentData['addModeTitle'];
            $csvFieldset->description = $currentData['addModeDescription'];
            $csvFieldset->notes = $currentData['addModeNotes'];
            $csvFieldset->showIf = "edit_mode=add";
            $childEditSet->add($csvFieldset);

            if(is_array($currentData['csvOptions']) && in_array('paste', $currentData['csvOptions']) || !$currentData['csvOptions']) {
                $f = $this->modules->get("InputfieldTextarea");
                $f->name = "childPagesAdd";
                $f->showIf = "edit_mode=add";
                $f->label = __("Text / Paste CSV");
                if($currentData['ignoreFirstRow']) $f->notes = __("If first row is 'Title' then the import settings were initially set to ignore first row of the entered data.");
                $f->attr('value', $currentData['ignoreFirstRow'] ? 'Title' : '');
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('paste',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->append($f);
            }

            if(is_array($currentData['csvOptions']) && in_array('link', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldURL");
                $f->name = "csvUrlAdd";
                $f->showIf = "edit_mode=add";
                $f->label = __("Enter URL to CSV file");
                $f->placeholder = __("URL to CSV file");
                $f->attr('value', '');
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('link',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->append($f);
            }

            if(is_array($currentData['csvOptions']) && in_array('upload', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldMarkup");
                $f->label = __("Upload CSV file");
                $f->name = 'csvUploadAdd';
                $f->showIf = "edit_mode=add";
                $f->value = "<input name='csvAddFile' type='file' />";
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('upload',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->add($f);
            }

        }

        // Update
        if(in_array('update', $currentData['editModes'])) {

            $csvFieldset = $this->modules->get("InputfieldFieldset");
            $csvFieldset->label = $currentData['updateModeTitle'];
            $csvFieldset->description = $currentData['updateModeDescription'];
            $csvFieldset->notes = $currentData['updateModeNotes'];
            $csvFieldset->showIf = "edit_mode=update";
            $childEditSet->add($csvFieldset);

            if(($currentData['csvOptions'] && in_array('paste', $currentData['csvOptions'])) || !$currentData['csvOptions']) {
                $f = $this->modules->get("InputfieldTextarea");
                $f->name = "childPagesUpdate";
                $f->showIf = "edit_mode=update";
                $f->label = __("Text / Paste CSV");
                if($currentData['ignoreFirstRow']) $f->notes = __("If first row is 'Title' then the import settings were initially set to ignore first row of the entered data.");
                $f->attr('value', $this->childPages);
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('paste',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->append($f);
            }

            if($currentData['csvOptions'] && in_array('link', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldURL");
                $f->name = "csvUrlUpdate";
                $f->showIf = "edit_mode=update";
                $f->label = __("Enter URL to CSV file");
                $f->placeholder = __("URL to CSV file");
                $f->attr('value', '');
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('link',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->append($f);
            }

            if($currentData['csvOptions'] && in_array('upload', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldMarkup");
                $f->label = __("Upload CSV file");
                $f->name = 'csvUploadUpdate';
                $f->showIf = "edit_mode=update";
                $f->value = "<input name='csvUpdateFile' type='file' />";
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('upload',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->add($f);
            }

        }

        // Replace
        if(in_array('replace', $currentData['editModes'])) {

            $csvFieldset = $this->modules->get("InputfieldFieldset");
            $csvFieldset->label = $currentData['replaceModeTitle'];
            $csvFieldset->description = $currentData['replaceModeDescription'];
            $csvFieldset->notes = $currentData['replaceModeNotes'];
            $csvFieldset->showIf = "edit_mode=replace";
            $childEditSet->add($csvFieldset);

            if(is_array($currentData['csvOptions']) && in_array('paste', $currentData['csvOptions']) || !$currentData['csvOptions']) {
                $f = $this->modules->get("InputfieldTextarea");
                $f->name = "childPagesReplace";
                $f->showIf = "edit_mode=replace";
                $f->label = __("Text / Paste CSV");
                if($currentData['ignoreFirstRow']) $f->notes = __("If first row is 'Title' then the import settings were initially set to ignore first row of the entered data.");
                $f->attr('value', $this->childPages);
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('paste',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->append($f);
            }

            if(is_array($currentData['csvOptions']) && in_array('link', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldURL");
                $f->name = "csvUrlReplace";
                $f->showIf = "edit_mode=replace";
                $f->label = __("Enter URL to CSV file");
                $f->placeholder = __("URL to CSV file");
                $f->attr('value', '');
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('link',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->append($f);
            }

            if(is_array($currentData['csvOptions']) && in_array('upload', $currentData['csvOptions'])) {
                $f = $this->modules->get("InputfieldMarkup");
                $f->label = __("Upload CSV file");
                $f->name = 'csvUploadReplace';
                $f->showIf = "edit_mode=replace";
                $f->value = "<input name='csvReplaceFile' type='file' />";
                if(!$currentData['csvOptionsCollapsed'] || ($currentData['csvOptionsCollapsed'] && !in_array('upload',$currentData['csvOptionsCollapsed']))) $f->collapsed = Inputfield::collapsedYes;
                $csvFieldset->add($f);
            }

        }

        // Edit
        if(in_array('edit', $currentData['editModes'])) {
            $results = $this->modules->get('InputfieldMarkup');
            $results->attr('id', 'edit');
            $results->showIf = "edit_mode=edit";
            $results->label = $currentData['editModeTitle'];
            $results->description = $currentData['editModeDescription'];
            $results->notes = $currentData['editModeNotes'];
            $table = $this->modules->get('MarkupAdminDataTable');
            $table->headerRow(array(
                __('Sort'),
                __('Title'),
                __('Name'),
                __('Template'),
                __('Hidden'),
                __('Unpublished'),
                __('View'),
                __('Edit'),
                __('Delete')
            ));
            $table->setSortable(true);
            $table->setEncodeEntities(false);

            //Build the table
            $allTemplateIds = array();
            foreach($this->templates as $template) $allTemplateIds[] = $template->id;
            $possibleTemplates = $pp->template->childTemplates ? $pp->template->childTemplates : $allTemplateIds;

            $defaultTemplateOptions = "<select name = 'templateId[new_0]'>";
            foreach($possibleTemplates as $templateId) {
                $t = $this->templates->get($templateId);
                if(!$this->isAllowedTemplateAdd($templateId, $pp)) continue;
                $defaultTemplateOptions .= '<option value = "'.$t->id.'">' . ($t->label ? $t->label : $t->name) . '</option>';
            }
            $defaultTemplateOptions .= "</select>";

            $rowNum=1;
            //if no children already, set up initial table row with blank name and delete button cells
            if(count($pp->children("include=all"))==0){
                $row = array(
                    "<i style='cursor:move' class='fa fa-arrows InputfieldChildTableRowSortHandle'></i>",
                    "<input id='' type='text' name='individualChildTitles[new_0]' value='' style='width:100%' />",
                    "",
                    $defaultTemplateOptions,
                    "",
                    "",
                    "",
                    "",
                    ""
                );
                $table->row($row);
                $rowNum++;
            }
            foreach ($pp->children("include=all") as $cp) {

                if ($cp->is(Page::statusSystemID)) continue; //Don't display if it is a system page (404, admin, trash etc)

                $allowPublish = true;
                if(!$this->wire('user')->isSuperuser()) {
                    $publishPermission = $this->wire('permissions')->get('page-publish');
                    if($publishPermission->id && !$this->wire('user')->hasPermission('page-publish')) $allowPublish = false;
                }

                $templateOptions = '';

                //if template of current page is not an allowed template, we still need to list it so manually add
                if(!in_array($cp->template->id, $possibleTemplates)) $templateOptions .= '<option value = "'.$cp->template->id.'" selected>' . ($cp->template->label ? $cp->template->label : $cp->template->name) . '</option>';

                //populate select with possible templates to choose from
                foreach($possibleTemplates as $templateId) {
                    $t = $this->templates->get($templateId);
                    if(!$this->isAllowedTemplateEdit($templateId, $cp)) continue;
                    $templateOptions .= '<option value = "'.$t->id.'" '.($t->id == $cp->template->id ? 'selected' : '').'>' . ($t->label ? $t->label : $t->name) . '</option>';
                }

                $row = array(
                    $pp->sortfield == 'sort' && $cp->sortable() ? "<i style='cursor:move'  class='fa fa-arrows InputfieldChildTableRowSortHandle'></i>" : "",
                    "<input id='{$cp->id}' type='text' name='individualChildTitles[{$cp->id}]' value='{$cp->title}' style='width:100%' ". (!$cp->editable() ? " readonly" : "") . " />",
                    '<span style="' . ($cp->is(Page::statusUnpublished) ? 'text-decoration:line-through;' : '') . ($cp->is(Page::statusHidden) ? 'color:#8c8c8c;' : '') . '">'.$cp->name.'</span>',
                    $currentData['allowTemplateChanges'] && $this->user->hasPermission("page-template", $cp) ? '<select name = "templateId['.$cp->id.']">' . $templateOptions . '</select>' : $cp->template->name,
                    '<input class="hiddenStatus" name="hiddenStatus['.$cp->id.']" type="checkbox" '.($cp->is(Page::statusHidden) ? 'checked' : '').'/>',
                    '<input class="unpublishedStatus" name="unpublishedStatus['.$cp->id.']" type="checkbox"'.($cp->is(Page::statusUnpublished) ? ' checked' : '').(!$allowPublish ? ' disabled' : '').'/>',
                    $cp->viewable() ? ' <a href="'.$cp->httpUrl.'" target="_blank"><i style="cursor:pointer" class="fa fa-eye"></i></a>' : '',
                    $cp->editable() ? '<a class="childChildTableEdit" data-url="./?id='.$cp->id.'&amp;modal=1" href="#"><i style="cursor:pointer" class="fa fa-pencil"></i></a>' : '',
                    $cp->trashable() ? "<i style='cursor:pointer' class='fa fa-trash-o InputfieldChildTableRowDeleteLink'></i>" : ""
                );
                $table->row($row);
                $rowNum++;
            }

            $hiddenInfo = "
            <div id='defaultTemplates' style='display:none'>$defaultTemplateOptions</div>
            <input name='idsToDelete' class='InputfieldChildTableRowDelete' type='hidden' value='' />
            ";

            if($pp->addable()) {
                $button = $this->wire('modules')->get('InputfieldButton');
                $button->icon = 'plus-circle';
                $button->value = $this->_x('Add New', 'button');
                $button->attr('class', 'ui-button ui-widget ui-corner-all ui-state-default InputfieldChildTableAddRow');
            }

            $results->attr('value', $hiddenInfo . '<div class="childChildTableContainer">' . $table->render() . '</div>' . ($pp->addable() ? $button->render() : ''));
            $childEditSet->append($results);
        }


        // Export
        if(in_array('export', $currentData['editModes'])) {

            //if Process helper module is not installed, install it
            if(!wire('modules')->isInstalled("ProcessChildrenCsvExport")) wire('modules')->get("ProcessChildrenCsvExport");

            $exportFieldset = $this->modules->get("InputfieldFieldset");
            $exportFieldset->label = $currentData['exportModeTitle'];
            $exportFieldset->description = $currentData['exportModeDescription'];
            $exportFieldset->notes = $currentData['exportModeNotes'];
            $exportFieldset->showIf = "edit_mode=export";
            $childEditSet->add($exportFieldset);

            $allFields = array();
            foreach($pp->children as $child) {
                foreach($child->fields as $cf) {
                    if(!in_array($cf, $allFields)) $allFields[] = $cf;
                }
            }

            if($currentData['allowOverrideCsvExportSettings']) {

                if(isset($this->data['pageSettings'][$pp->id])) {
                    $f = wire('modules')->get("InputfieldAsmSelect");
                    $f->name = "userExportFields";
                    $f->showIf = "edit_mode=export";
                    $f->label = __('Fields to export');
                    $f->description = __('Choose and sort the fields to include in the CSV export');

                    //system field labels
                    foreach($this->data['systemFields'] as $systemField => $systemFieldLabel) {
                        $fieldLabels[$systemField] = $systemFieldLabel;
                    }

                    //custom template field labels for all child pages
                    foreach($allFields as $pf) {
                        $fieldLabels[$pf->name] = $pf->label ? $pf->label : $pf->name;
                    }

                    //populate user override export field list from the page's Settings tab
                    $populatedFields = array();
                    foreach($this->data['pageSettings'][$pp->id]['exportFields'] as $exportField) {
                        $populatedFields[] = $exportField;
                        $f->addOption($exportField, $fieldLabels[$exportField]);
                        $f->value = $exportField;
                    }

                    //all other fields not already populated
                    //system fields
                    foreach($this->data['systemFields'] as $systemField => $systemFieldLabel) {
                        if(!in_array($systemField, $populatedFields)) $f->addOption($systemField, $systemFieldLabel);
                    }
                    $allFields = array();
                    foreach(wire('pages')->get(wire('input')->get->id)->children as $child) {
                        foreach($child->fields as $cf) {
                            if(!in_array($cf, $allFields)) $allFields[] = $cf;
                        }
                    }

                    //custom template fields for all child pages
                    foreach($allFields as $pf) {
                        if(!in_array($pf->name, $populatedFields)) $f->addOption($pf->name, $pf->label ? $pf->label : $pf->name);
                    }

                    $exportFieldset->add($f);
                }

                $f = $this->modules->get("InputfieldText");
                $f->name = 'export_column_separator';
                $f->label = __('Columns separated with');
                $f->notes = __('For tab separated, enter: tab');
                $f->value = $currentData['csvExportFieldSeparator'];
                $f->columnWidth = 20;
                $exportFieldset->add($f);

                $f = $this->modules->get("InputfieldText");
                $f->name = 'export_column_enclosure';
                $f->label = __('Column enclosure');
                $f->value = $currentData['csvExportFieldEnclosure'];
                $f->columnWidth = 20;
                $exportFieldset->add($f);

                $f = $this->modules->get("InputfieldText");
                $f->name = 'export_extension';
                $f->label = __('File extension');
                $f->value = $currentData['csvExportExtension'];
                $f->columnWidth = 20;
                $exportFieldset->add($f);

                $f = wire('modules')->get("InputfieldText");
                $f->attr('name', 'multiple_values_separator');
                $f->label = __('Multiple values separator');
                $f->description = __('Separator for multiple values like Page fields, files/images, multiplier, etc.');
                $f->notes = __('Default is | Other useful options include \r for new lines when importing into Excel.');
                $f->value = $currentData['multipleValuesSeparator'];
                $f->columnWidth = 20;
                $exportFieldset->add($f);

                $f = $this->modules->get("InputfieldCheckbox");
                $f->name = 'export_names_first_row';
                $f->label = __('Column labels');
                $f->label2 = 'Put column names in the first row';
                $f->attr('checked', $currentData['columnsFirstRow'] ? 'checked' : '' );
                $f->columnWidth = 20;
                $exportFieldset->add($f);
            }
            //if there is no user override then populate hidden so .js file can get these value and pass them to the Process helper module
            else {
                $f = $this->modules->get("InputfieldMarkup");
                $f->attr('name', 'csv_settings');
                $exportFields = $currentData['exportFields'] ? implode(',', $currentData['exportFields']) : implode(',', $allFields);
                $f->value = "
                <input id='Inputfield_exportFields' type='hidden' value='{$exportFields}' />
                <input id='Inputfield_export_column_separator' type='hidden' value='{$currentData['csvExportFieldSeparator']}' />
                <input id='Inputfield_export_column_enclosure' type='hidden' value='{$currentData['csvExportFieldEnclosure']}' />
                <input id='Inputfield_export_extension' type='hidden' value='{$currentData['csvExportExtension']}' />
                <input id='Inputfield_multiple_values_separator' type='hidden' value='{$currentData['multipleValuesSeparator']}' />
                <input id='Inputfield_export_names_first_row' type='hidden' value='{$currentData['columnsFirstRow']}' />
                ";
                $exportFieldset->add($f);
            }

            $f = $this->modules->get("InputfieldButton");
            $f->name = 'export_button';
            $f->value = $this->_x('Export as CSV', 'button');
            $f->attr('class', 'ui-button ui-widget ui-corner-all ui-state-default children_export_csv');
            $f->attr('data-pageid', (int) $this->input->id);
            $exportFieldset->add($f);

            $f = $this->modules->get("InputfieldMarkup");
            $f->attr('name', 'iframe');
            $f->value = "<iframe id='download' src=''></iframe>";
            $exportFieldset->add($f);

        }

        return $childEditSet;
    }


    public function saveChildren(HookEvent $event){

        // early exit if no mode has been selected
        if(!$this->input->post->edit_mode) return;

        // ProcessPageEdit's processInput function may go recursive, so we want to skip
        // the instances where it does that by checking the second argument named "level"
        $level = $event->arguments(1);
        if($level > 0) return;

        //set the current edit mode so it can be opened after saving the page
        $this->session->edit_mode = $this->input->post->edit_mode;

        $pp = $event->object->getPage();

        //populate currentData with pageSettings version if page has specific settings
        $currentData = in_array($pp->id, $this->data['configurablePages']) && isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        //get user CSV setting overrides if allowed
        if((isset($currentData['allowOverrideCsvImportSettings']) && $currentData['allowOverrideCsvImportSettings'])) {
            $currentData['fieldSeparator'] = $this->session->userCsvImportFieldSeparator;
            $currentData['fieldEnclosure'] = $this->session->userCsvImportFieldEnclosure;
            $currentData['ignoreFirstRow'] = $this->session->userIgnoreFirstRow;
        }

        //use the selected template or if none selected then it means there is only one childTemplate option [0], so use that
        $childTemplate = $this->input->post->childTemplate ? $this->input->post->childTemplate : $pp->template->childTemplates[0];

        //Replace Mode
        if($this->input->post->edit_mode == "replace"){

            $childPagesReplace = $this->processTextOrFile($this->input->post->childPagesReplace, $this->input->post->csvUrlReplace,'csvReplaceFile');

            //if theURL or CSV versions are empty, escape now to prevent unwanted deletion and recreation of pages
            //note that an empty textarea/paste option is valid - it provides a way to batch delete all child pages
            if($childPagesReplace == 'BCE-FILE-EMPTY') {
                $this->error($this->_("The CSV file was empty, so no pages can be created."));
                return;
            }
            //if content (textarea, URL or CSV upload) hasn't changed, escape now to prevent unwanted deletion and recreation of pages
            if($childPagesReplace == $this->childPages) return;


            if(!$currentData['disableContentProtection']){
                foreach($pp->children("include=all") as $cp){
                    if($cp->numChildren>0){
                        $this->error($this->_("You cannot batch replace these child pages, because at least one page has a child page of its own. Try the edit option, or delete existing child pages first."));
                        return;
                    }
                    foreach($cp->fields as $cpfield){
                        if($cpfield->name != 'title' && $cp->$cpfield !=''){
                            $this->error($this->_("You cannot batch replace these child pages, because at least one page has a field which is not empty. Try the edit option, or delete existing child pages first."));
                            return;
                        }
                    }
                }
            }
            $this->createPages($childPagesReplace, $pp, $childTemplate);
        }
        //Update Mode
        elseif($this->input->post->edit_mode == "update"){

            $childPagesUpdate = $this->processTextOrFile($this->input->post->childPagesUpdate, $this->input->post->csvUrlUpdate,'csvUpdateFile');

            //if theURL or CSV versions are empty, escape now to prevent unwanted deletion and recreation of pages
            //note that an empty textarea/paste option is valid - it provides a way to batch delete all child pages
            if($childPagesUpdate == 'BCE-FILE-EMPTY') {
                $this->error($this->_("The CSV file was empty, so no pages can be created."));
                return;
            }
            //if content (textarea, URL or CSV upload) hasn't changed, escape now to prevent unwanted deletion and recreation of pages
            if($childPagesUpdate == $this->childPages) return;

            $this->createPages($childPagesUpdate, $pp, $childTemplate);
        }
        //Add mode
        elseif($this->input->post->edit_mode == "add"){
            $childPagesAdd = $this->processTextOrFile($this->input->post->childPagesAdd, $this->input->post->csvUrlAdd, 'csvAddFile');
            $this->createPages($childPagesAdd, $pp, $childTemplate);
        }
        //Edit Mode
        else{
            //delete any pages marked for deletion
            if($this->input->post->idsToDelete!=''){
                $idsToDelete = explode(',', $this->input->post->idsToDelete);
                foreach($idsToDelete as $id){
                    $ptod = $this->pages->get($id);

                    if(!$currentData['disableContentProtection']){
                        if($ptod->numChildren>0){
                            $this->error($this->_("You cannot delete this child page, because it has a child page of its own. You can prevent this check by disabling Content Protection in the module config settings."));
                            return;
                        }
                        if(is_array($ptod->fields) && !empty($ptod->fields)) {
                            foreach($ptod->fields as $ptodfield){
                                if($ptodfield->name != 'title' && $ptod->$ptodfield !=''){
                                    $this->error($this->_("You cannot delete this child page, because it has a field which is not empty. You can prevent this check by disabling Content Protection in the module config settings."));
                                    return;
                                }
                            }
                        }
                    }

                    if($id!='' && $ptod->trashable()) {
                        $currentData['trashOrDelete'] == 'delete' ? $this->pages->delete($ptod, true) : $this->pages->trash($ptod);
                    }
                }
            }

            $i=0;
            foreach($this->input->post->individualChildTitles as $id => $childTitle){
                if(isset($idsToDelete) && in_array($id, $idsToDelete)) continue; //ignore pages that have just been deleted
                $childTitle = trim($this->sanitizer->text($childTitle));
                $i++;
                if($childTitle == '') continue; // in case someone clicked add Page, but left it blank
                // new page
                elseif(strpos($id, 'new') !== FALSE){
                    if((is_array($pp->template->childTemplates) && !empty($pp->template->childTemplates) && !in_array($this->input->post->templateId[$id], $pp->template->childTemplates)) || $this->templates->get($this->input->post->templateId[$id])->noParents) {
                        $this->error($this->_("Some pages could not be created due to template family settings."));
                        continue;
                    }
                    $cp = new Page();
                    $cp->parent = $pp;
                    $cp->template = $this->input->post->templateId[$id];
                    if(isset($this->input->post->hiddenStatus[$id])) $cp->addStatus(Page::statusHidden);
                    if(isset($this->input->post->unpublishedStatus[$id])) $cp->addStatus(Page::statusUnpublished);
                }
                // existing page
                else{
                    $cp = $this->pages->get($id);

                    if($currentData['allowTemplateChanges'] && $this->user->hasPermission("page-template", $cp)) $cp->template = $this->input->post->templateId[$cp->id];

                    if(isset($this->input->post->hiddenStatus[$cp->id])) {
                        $cp->addStatus(Page::statusHidden);
                    }
                    else {
                        $cp->removeStatus(Page::statusHidden);
                    }

                    if(isset($this->input->post->unpublishedStatus[$cp->id])) {
                        $cp->addStatus(Page::statusUnpublished);
                    }
                    else {
                        $cp->removeStatus(Page::statusUnpublished);
                    }

                    //if($i==1 && !$this->input->post->childTemplate) $childTemplate = $cp->template->name; //get the template of the first child in case we need it to assign to a newly added page
                }
                $cp->title = $childTitle;
                if($this->input->post->userOverwriteNames || (!$this->input->post->userOverwriteNames && !$currentData['allowOverrideOverwriteNames'] && $currentData['overwriteNames'])){
                    $n = 0;
                    $pageName = $this->sanitizer->pageName($childTitle, Sanitizer::translate);
                    if($cp->isNew()){
                        do {
                            $name = $pageName . ($n ? "-$n" : '');
                            $child = $pp->child("name=$name"); // see if another page already has the same name
                            $n++;
                        } while($child->id);
                    }
                    else{
                        $name = $pageName;
                    }
                    $cp->name = $name;
                }
                $cp->sort = $i;

                if($cp->isChanged()) {
                    $cp->of(false);
                    $cp->save();
                }
            }
        }
    }



    public function processTextOrFile ($str, $link, $fileInputName) {

        //CSV file upload
        if(isset($_FILES[$fileInputName]['name']) && $_FILES[$fileInputName]['name'] !== ''){

            $csv_file_extension = pathinfo($_FILES[$fileInputName]["name"], PATHINFO_EXTENSION);

            if($csv_file_extension == 'csv' || $csv_file_extension == 'txt' || $csv_file_extension == 'tsv'){
                $childPagesContent = file_get_contents($_FILES[$fileInputName]["tmp_name"]);
                if($childPagesContent == '') return 'BCE-FILE-EMPTY';
            }
            else{
                $this->error($this->_("That is not an allowed file extension for a CSV import. Try again with a .csv, .tsv, or .txt file"));
            }

            unlink($_FILES[$fileInputName]["tmp_name"]);
        }
        elseif($link != '') {
            $childPagesContent = file_get_contents($link);
            if($childPagesContent == '') return 'BCE-FILE-EMPTY';
        }
        elseif($str != '') $childPagesContent = $str;
        else return;

        return mb_check_encoding($childPagesContent, 'UTF-8') ? $childPagesContent : utf8_encode($childPagesContent);
    }



    public function createPages($childPages, $pp, $childTemplate) {

        $childPages = trim(preg_replace("/(^[\r\n]*|[\r\n]+)[\s\t]*[\r\n]+/", "\n", $childPages),"\n"); // remove any blank lines
        $childPages = str_replace("\r\n","\n", $childPages); //fix for Windows line endings
        $childPages = str_replace("\r","\n", $childPages); //fix for Mac Excel line ending issue - http://nicercode.github.io/blog/2013-04-30-excel-and-line-endings/
        if($childPages == '') return;
        $childPagesArray = explode("\n",$childPages);

        //populate currentData with pageSettings version if page has specific settings
        $currentData = in_array($pp->id, $this->data['configurablePages']) && isset($this->data['pageSettings'][$pp->id]) && $this->data['pageSettings'][$pp->id] ? $this->data['pageSettings'][$pp->id] : $this->data;

        //get user CSV setting overrides if allowed
        if((isset($currentData['allowOverrideCsvImportSettings']) && $currentData['allowOverrideCsvImportSettings'])) {
            $currentData['fieldSeparator'] = $this->session->userCsvImportFieldSeparator = $this->input->post->userCsvImportFieldSeparator;
            $currentData['fieldEnclosure'] = $this->session->userCsvImportFieldEnclosure = $this->input->post->userCsvImportFieldEnclosure;
            $currentData['ignoreFirstRow'] = $this->session->userIgnoreFirstRow = $this->input->post->userIgnoreFirstRow;
        }

        //if defined, get field pairings
        if(isset($this->data['pageSettings'][$pp->id]['fieldPairings']) && $this->data['pageSettings'][$pp->id]['fieldPairings'] != '') {
            $convertedFieldPairings = $this->convertFieldPairings($currentData['fieldPairings']);
            //if it exists, move title to first position in array but maintain keys for pairing to CSV columns
            $titleKey = array_search('title', $convertedFieldPairings);
            if($titleKey) $convertedFieldPairings = array($titleKey => $convertedFieldPairings[$titleKey]) + $convertedFieldPairings;
        }

        //iterate through rows in childpages data (text/paste, URL, or uploaded CSV)
        $x=0;
        foreach($childPagesArray as $childPage) {

            $i=0;
            $x++;

            $row = str_getcsv($childPage, $currentData['fieldSeparator'] == "tab" ? chr(9) : $currentData['fieldSeparator'], $currentData['fieldEnclosure']);

            //if fields pairings are not defined, then make sure the field count matches the number of fields in the selected child template
            if(!isset($this->data['pageSettings'][$pp->id]['fieldPairings']) || $this->data['pageSettings'][$pp->id]['fieldPairings'] == '') {
                //only if greater than one, because one column in each row is just for setting the title/name
                if(count($row) > 1 && count($row) != count($this->templates->get($childTemplate)->fields)) {
                    $this->error($this->_("The number of columns/fields in your CSV do not match the number of fields in the template. Nothing can be safely imported. If you need to exclude certain fields, make sure the CSV has blank values for the excluded fields."));
                    return;
                }
            }
            //if field pairings are defined, check that the field/column count in the CSV is at least as many as the number of defined pairings
            //if field pairings are defined then we don't allow titles only (unless that is the only pairing defined), hence no check for count($row) > 1
            else {
                if(count($row) < count($convertedFieldPairings)) {
                    $this->error($this->_("The number of columns/fields in your CSV is not enough for number of fields defined for this import. Nothing can be safely imported."));
                    return;
                }
            }

            //if first loop and replace mode then now it's safe to delete all existing child pages because above checks for field pairings have passed
            if(($x==1 || ($x==2 && $currentData['ignoreFirstRow'])) && $this->input->post->edit_mode == "replace") {
                foreach($pp->children("include=all") as $cp) {
                    if(!$cp->is(Page::statusSystemID) && $cp->trashable()) {
                        $currentData['trashOrDelete'] == 'delete' ? $this->pages->delete($cp, true) : $this->pages->trash($cp);
                    }
                }
            }

            if($x==1 && $currentData['ignoreFirstRow']) continue;
            //create new or edit existing child pages
            //if fieldPairings is defined and this is first column, then set name/title and create new / get existing page
            if($i==0 && $currentData['fieldPairings'] != '') {
                // if title key exists, then make sure it is populated
                // not necessary in update mode only setups so it may be not set
                if($titleKey && $row[$titleKey-1] == '') continue;
                //update mode so re-title/re-name existing page
                if($this->input->post->edit_mode == "update") {
                    $np = $pp->children->eq($currentData['ignoreFirstRow'] ? $x-2 : $x-1);
                    if($this->input->post->userOverwriteNames || (!$this->input->post->userOverwriteNames && !$currentData['allowOverrideOverwriteNames'] && $currentData['overwriteNames'])){
                        if($titleKey) $np->name = trim($this->sanitizer->pageName($row[$titleKey-1], Sanitizer::translate));
                    }
                }
                //not update mode, so create new page
                else {
                    $np = new Page();
                    $np->parent = $pp;
                    $np->template = $childTemplate;
                }

                if($titleKey) $np->title = trim($this->sanitizer->text($row[$titleKey-1]));
                if($np->isChanged("title")) {
                    $np->of(false);
                    $np->save();
                }
            }

            //creating pages and populating fields
            foreach($row as $childField) {
                $childField = trim($this->sanitizer->text($childField));
                //if fieldPairings is defined now populate the rest of the fields
                if($currentData['fieldPairings'] != '') {
                    //populate new page with rest of the field values
                    if(isset($convertedFieldPairings[$i+1]) && $convertedFieldPairings[$i+1] !== 'title') { // no need to redefine the title field value
                        //check for subfields (eg textareas pro field) with a period (.) separator
                        if (strpos($convertedFieldPairings[$i+1],'.')){
                            $fieldParts = explode('.', $convertedFieldPairings[$i+1]);
                            $np->$fieldParts[0]->$fieldParts[1] = $childField;
                            if($np->isChanged($fieldParts[0])) {
                                $np->of(false);
                                $np->save($fieldParts[0]);
                            }
                        }
                        else {
                            $np->$convertedFieldPairings[$i+1] = $childField;
                            if($np->isChanged($convertedFieldPairings[$i+1])) {
                                $np->of(false);
                                $np->save($convertedFieldPairings[$i+1]);
                            }
                        }
                    }
                }
                // else field pairings not defined, so match all fields in order
                else {
                    //first item is the page title so create new page
                    if($i==0) {
                        if($childField == '') continue;
                        //update mode so re-title/re-name existing page
                        if($this->input->post->edit_mode == "update") {
                            $np = $pp->children->eq($currentData['ignoreFirstRow'] ? $x-2 : $x-1);
                            if($this->input->post->userOverwriteNames || (!$this->input->post->userOverwriteNames && !$currentData['allowOverrideOverwriteNames'] && $currentData['overwriteNames'])){
                                if($np->id) {
                                    $np->name = trim($this->sanitizer->pageName($childField, Sanitizer::translate));
                                }
                                // for new pages added at the end when using Update mode
                                else {
                                    if(!$pp->addable()) continue; //update mode is available to users without add permission, but they shouldn't be able to add new pages at the end
                                    $np = new Page();
                                    $np->parent = $pp;
                                    $np->template = $childTemplate;
                                }
                            }
                        }
                        //not update mode, so create new page
                        else {
                            $np = new Page();
                            $np->parent = $pp;
                            $np->template = $childTemplate;
                        }

                        $np->title = trim($this->sanitizer->text($childField));
                        if($np->isChanged("title")) {
                            $np->of(false);
                            $np->save();
                        }

                        //populate numeric array of field names
                        $fieldsArray = array();
                        foreach($np->fields as $f) $fieldsArray[] = $f->name;
                    }
                    //populate new page with rest of the field values
                    else {
                        $np->$fieldsArray[$i] = $childField;
                        if($np->isChanged($fieldsArray[$i])) {
                            $np->of(false);
                            $np->save($fieldsArray[$i]);
                        }
                    }
                }
                $i++;
            }
        }
    }


    /**
     * Return an InputfieldsWrapper of Inputfields used to configure the class
     *
     * @param array $data Array of config values indexed by field name
     * @return InputfieldsWrapper
     *
     */
    public static function getModuleConfigInputfields(array $data) {

        $data = array_merge(self::getDefaultData(), $data);

        $wrapper = new InputFieldWrapper();

        $fieldset = wire('modules')->get("InputfieldFieldset");
        $fieldset->attr('id', 'batch_child_editor_where_available_fieldset');
        $fieldset->label = __("Where editing tools are available and separately configurable");
        $fieldset->collapsed = Inputfield::collapsedYes;
        $wrapper->add($fieldset);

        $fieldEnabledTemplates = wire('modules')->get('InputfieldAsmSelect');
        $fieldEnabledTemplates->attr('name+id', 'enabledTemplates');
        $fieldEnabledTemplates->label = __('Enabled templates', __FILE__);
        $fieldEnabledTemplates->columnWidth = 33;
        $fieldEnabledTemplates->description = __("The batch editing option will only be available for the selected templates.\nNB Leave blank to allow all templates.", __FILE__);
        $fieldEnabledTemplates->setAsmSelectOption('sortable', false);

        // populate with all available templates
        foreach(wire('templates') as $t) {
            // filter out system templates
            if(!($t->flags & Template::flagSystem)) $fieldEnabledTemplates->addOption($t->name);
        }
        if(isset($data['enabledTemplates'])) $fieldEnabledTemplates->value = $data['enabledTemplates'];
        $fieldset->add($fieldEnabledTemplates);


        $fieldEnabledPages = wire('modules')->get('InputfieldPageListSelectMultiple');
        $fieldEnabledPages->attr('name+id', 'enabledPages');
        $fieldEnabledPages->label = __('Enabled pages', __FILE__);
        $fieldEnabledPages->columnWidth = 34;
        $fieldEnabledPages->description = __("The batch editing option will only be available for the selected pages.\nNB Leave blank to allow all pages.", __FILE__);
        if(isset($data['enabledPages'])) $fieldEnabledPages->value = $data['enabledPages'];
        $fieldset->add($fieldEnabledPages);

        $fieldConfigurablePages = wire('modules')->get('InputfieldPageListSelectMultiple');
        $fieldConfigurablePages->attr('name+id', 'configurablePages');
        $fieldConfigurablePages->label = __('Configurable pages', __FILE__);
        $fieldConfigurablePages->columnWidth = 33;
        $fieldConfigurablePages->description = __("Selected pages will have their own config settings for Batch Child Editor - these will be added to the page's Settings tab. All other pages will use the config settings below.", __FILE__);
        if(isset($data['configurablePages'])) $fieldConfigurablePages->value = $data['configurablePages'];
        $fieldset->add($fieldConfigurablePages);

        buildCoreSettings($data, $wrapper);

        return $wrapper;
    }


    public function convertFieldPairings ($fieldPairings) {
        //convert to array of column numbers and PW field names
        $temp = explode("\r\n", $fieldPairings);
        $convertedFieldPairings = array();
        foreach ($temp as $value) {
            $array = explode(':', str_replace(' ', '', $value));
            $array[1] = trim($array[1], '"');
            $convertedFieldPairings[$array[0]] = $array[1];
        }
        return $convertedFieldPairings;
    }


    /**
     * Returns an array of templates that are allowed to be used here
     *
     */
    protected function getAllowedTemplatesEdit() {

        if(is_array($this->allowedTemplates)) return $this->allowedTemplates;

        $templates = array();
        $user = $this->fuel('user');
        $isSuperuser = $user->isSuperuser();
        $page = $this->masterPage ? $this->masterPage : $this->page;
        $parent = $page->parent;
        $parentEditable = ($parent->id && $parent->editable());

        // current page template is assumed, otherwise we wouldn't be here
        $templates[$page->template->id] = $page->template;

        // check if they even have permission to change it
        if(!$user->hasPermission('page-template', $page) || $page->template->noChangeTemplate) {
            $this->allowedTemplates = $templates;
            return $templates;
        }

        $allTemplates = count($this->predefinedTemplates) ? $this->predefinedTemplates : $this->wire('templates');

        foreach($allTemplates as $template) {

            if(isset($templates[$template->id])) continue;

            if($template->flags & Template::flagSystem) {
                // if($template->name == 'user' && $parent->id != $this->config->usersPageID) continue;
                if(in_array($template->id, $this->config->userTemplateIDs) && !in_array($parent->id, $this->config->usersPageIDs)) continue;
                if($template->name == 'role' && $parent->id != $this->config->rolesPageID) continue;
                if($template->name == 'permission' && $parent->id != $this->config->permissionsPageID) continue;
            }

            if(count($template->parentTemplates) && $parent->id && !in_array($parent->template->id, $template->parentTemplates)) {
                // this template specifies it can only be used with certain parents, and our parent's template isn't one of them
                continue;
            }

            if($parent->id && count($parent->template->childTemplates)) {
                // the page's parent only allows certain templates for it's children
                // if this isn't one of them, then continue;
                if(!in_array($template->id, $parent->template->childTemplates)) continue;
            }

            if($isSuperuser) {
                $templates[$template->id] = $template;

            } else if($template->noParents) {
                // user can't change to a template that has been specified as no more instances allowed
                // except for superuser... we'll let them do it
                continue;

            } else if((!$template->useRoles && $parentEditable) || $user->hasPermission('page-edit', $template)) {
                // determine if the template's assigned roles match up with the users's roles
                // and that at least one of those roles has page-edit permission
                if($user->hasPermission('page-create', $page)) {
                    // user is allowed to create more pages of this type, so template may be used
                    $templates[$template->id] = $template;
                }
            }
        }

        $this->allowedTemplates = $templates;
        return $templates;
    }

    /**
     * Is the given template or template ID allowed here?
     *
     */
    protected function isAllowedTemplateEdit($id, $cp) {

        // if the template is the same one already in place, of course it's allowed
        if($id == $cp->template->id) return true;

        // if we've made it this far, then get a list of templates that are allowed...
        $templates = $this->getAllowedTemplatesEdit();

        // ...and determine if the supplied template is in that list
        return isset($templates[$id]);
    }


    /**
     * Returns an array of templates that are allowed to be used here
     *
     */
    protected function getAllowedTemplatesAdd($parent) {

        if(is_array($this->allowedTemplates)) return $this->allowedTemplates;

        $user = $this->wire('user');
        $templates = array();
        $allTemplates = count($this->predefinedTemplates) ? $this->predefinedTemplates : $this->wire('templates');
        $allParents = $this->getAllowedParentsAdd(null, $parent);
        $usersPageIDs = $this->wire('config')->usersPageIDs;
        $userTemplateIDs = $this->wire('config')->userTemplateIDs;

        if($parent->is(Page::statusUnpublished)) {
            $parentEditable = $parent->editable();
        } else {
            // temporarily put the parent in an unpublished status so that we can check it from
            // the proper context: when page-publish permission exists, a page not not editable
            // if a user doesn't have page-publish permission to it, even though it may still
            // be editable if it was unpublished.
            $parent->addStatus(Page::statusUnpublished);
            $parentEditable = $parent->editable();
            $parent->removeStatus(Page::statusUnpublished);
        }

        foreach($allTemplates as $t) {

            if($t->noParents) continue;
            if($t->useRoles && !$user->hasPermission('page-create', $t)) continue;
            if(!$t->useRoles && !$parentEditable) continue;
            if(!$t->useRoles && !$user->hasPermission('page-create', $parent)) continue;

            if(count($allParents) == 1) {
                if(count($parent->template->childTemplates)) {
                    // check that this template is allowed by the defined parent
                    if(!in_array($t->id, $parent->template->childTemplates)) continue;
                }
            }

            if(count($t->parentTemplates)) {
                // this template is only allowed for certain parents
                $allow = false;
                foreach($allParents as $parent) {
                    if(in_array($parent->template->id, $t->parentTemplates)) {
                        $allow = true;
                        break;
                    }
                }
                if(!$allow) continue;
            }

            if(in_array($t->id, $userTemplateIDs)) {
                // this is a user template: allow any parents defined in $config->usersPageIDs
                $allow = false;
                foreach($allParents as $parent) {
                    if(in_array($parent->id, $usersPageIDs)) {
                        $allow = true;
                        break;
                    }
                }
                if(!$allow) continue;

            } else if($t->name == 'role' && $parent->id != $this->config->rolesPageID) {
                // only allow role templates below rolesPageID
                continue;

            } else if($t->name == 'permission' && $parent->id != $this->config->permissionsPageID) {
                // only allow permission templates below permissionsPageID
                continue;
            }

            $templates[$t->id] = $t;
        }

        if($this->template || count($this->predefinedTemplates)) {
            $predefinedTemplates = count($this->predefinedTemplates) ? $this->predefinedTemplates : array($this->template);
            foreach($predefinedTemplates as $t) {
                $isUserTemplate = in_array($t->id, $userTemplateIDs);
                if($isUserTemplate && !isset($templates[$t->id]) && $user->hasPermission('user-admin')) {
                    // account for the unique situation of user-admin permission
                    // where all user-based templates are allowed
                    $templates[$t->id] = $t;
                }
            }
        }

        $this->allowedTemplates = $templates;

        return $templates;
    }


    /**
     * Get allowed parents
     *
     * This will always be 1-parent, unless predefinedParents was populated.
     *
     * @param Template $template Optionally specify a template to filter parents by
     * @return PageArray
     *
     */
    protected function getAllowedParentsAdd(Template $template = null, $pp) {
        if(count($this->predefinedParents)) {
            $parents = $this->predefinedParents;
        } else {
            $parents = new PageArray();
            if($pp) $parents->add($pp);
        }
        foreach($parents as $parent) {
            if(!$parent->addable()) $parents->remove($parent);
            if($parent->template->noChildren) $parents->remove($parent);
            if($template && count($parent->template->childTemplates)) {
                // parent only allows certain templates for children
                // if a template was given in the arguments, check that it is allowed
                if(!in_array($template->id, $parent->template->childTemplates)) {
                    $parents->remove($parent);
                }
            }
        }
        if($template && count($template->parentTemplates)) {
            // given template only allows certain parents
            foreach($parents as $parent) {
                if(!in_array($parent->template->id, $template->parentTemplates)) {
                    $parents->remove($parent);
                }
            }
        }
        return $parents;
    }


    /**
     * Is the given template or template ID allowed here?
     *
     * @param Template|int Template ID or object
     * @param Page $parent Optionally parent page to filter by
     * @return bool
     * @throws WireException of template argument can't be resolved
     *
     */
    protected function isAllowedTemplateAdd($template, Page $parent = null) {
        if(!is_object($template)) $template = $this->wire('templates')->get($template);
        if(!$template) throw new WireException('Unknown template');
        $templates = $this->getAllowedTemplatesAdd($parent);
        $allowed = isset($templates[$template->id]);
        if($allowed && $parent) {
            if(count($parent->template->childTemplates) && !in_array($template->id, $parent->template->childTemplates)) {
                $allowed = false;
            } else if($parent->template->noChildren) {
                $allowed = false;
            } else if(count($template->parentTemplates) && !in_array($parent->template->id, $template->parentTemplates)) {
                $allowed = false;
            } else if($template->noParents) {
                $allowed = false;
            }
        }
        return $allowed;
    }


    /**
     * Called only when your module is installed
     *
     * Create a new permission.
     *
     */
    public function ___install() {
        $permission = $this->permissions->get('batch-child-editor');
        if (!$permission->id) {
            $p = new Permission();
            $p->name = 'batch-child-editor';
            $p->title = $this->_('Use Batch Child Editor');
            $p->save();
            // tell the user we created this module's permission
            $this->message($this->_("Created New Permission: batch-child-editor"));
            $this->message($this->_("Assigned batch-child-editor permission to superuser"));
        }

        $su = $this->roles->get("superuser");
        $su->addPermission("batch-child-editor");
        $su->save();
    }

    /**
     * Called only when your module is uninstalled
     *
     * Remove the special permission
     *
     */
    public function ___uninstall() {
        $permission = $this->permissions->get('batch-child-editor');
        if ($permission->id) {
            $permission->delete();
            $this->message($this->_("Deleted Permission: batch-child-editor"));
        }
    }

}


function buildCoreSettings ($data, $wrapper, $pid = null) {

    $fieldset = wire('modules')->get("InputfieldFieldset");
    $fieldset->attr('id', 'batch_child_editor_mode_settings_fieldset');
    $fieldset->label = __("Mode Settings");
    $fieldset->collapsed = Inputfield::collapsedYes;
    $wrapper->add($fieldset);

    $f = wire('modules')->get("InputfieldCheckboxes");
    $f->attr('name', 'editModes');
    $f->label = __('Modes');
    $f->required = true;
    $f->columnWidth = 25;
    $f->description = __('Which modes you want available. If more than one checked, then the user can decide.');
    $f->addOption("edit","Edit");
    $f->addOption("add","Add");
    $f->addOption("update","Update");
    $f->addOption("replace","Replace");
    $f->addOption("export","Export CSV");
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['editModes'] : $data['editModes'];
    $f->notes = __("The Edit and Add modes are safer than the Update and Replace modes, because they are non-destructive.\n\nUpdate will edit the content of fields of existing pages. Replace will delete all child pages and create new ones.");
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldRadios");
    $f->attr('name', 'defaultMode');
    $f->label = __('Default Mode');
    $f->columnWidth = 25;
    $f->showIf = "editModes.count>1";
    $f->description = __('If more than one mode available to user, which one should be open by default.');
    $f->addOption("","None");
    $f->addOption("edit","Edit");
    $f->addOption("add","Add");
    $f->addOption("update","Update");
    $f->addOption("replace","Replace");
    $f->addOption("export","Export CSV");
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['defaultMode'] : $data['defaultMode'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'overwriteNames');
    $f->label = __('Overwrite names');
    $f->showIf = "editModes=edit|update";
    $f->columnWidth = 25;
    $f->description = __('Whether to overwrite the name of the page, and not just the title.');
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['overwriteNames'] : $data['overwriteNames']) ? 'checked' : '' );
    $f->notes = __("Only relevant for Edit and Update modes. This option can cause problems if the affected child pages are part of the front end structure of the site. It may result in broken links, etc.");
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'allowOverrideOverwriteNames');
    $f->label = __('Allow user to change "Overwrite Names" setting');
    $f->showIf = "editModes=edit|update";
    $f->columnWidth = 25;
    $f->description = __('Whether an admin user can change the override option when doing a batch edit.');
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['allowOverrideOverwriteNames'] : $data['allowOverrideOverwriteNames']) ? 'checked' : '' );
    $f->notes = __("Only relevant for Edit and Update modes.");
    $fieldset->add($f);

    $fieldset = wire('modules')->get("InputfieldFieldset");
    $fieldset->attr('id', 'batch_child_editor_data_protection_fieldset');
    $fieldset->label = __("Content Deletion / Protection");
    $fieldset->showIf = "editModes=edit|add|update|replace";
    $fieldset->collapsed = Inputfield::collapsedYes;
    $wrapper->add($fieldset);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'disableContentProtection');
    $f->label = __('Disable content protection');
    $f->showIf = "editModes=replace|edit";
    $f->columnWidth = 33;
    $f->description = __('If checked, replace mode will destructively replace children even if they have additional field content and grandchildren. In edit mode it allows deletion of pages that have their own children.');
    $f->notes = __("This can be extremely destructive, use with extreme caution!");
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['disableContentProtection'] : $data['disableContentProtection']) ? 'checked' : '' );
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'allowTemplateChanges');
    $f->label = __('Allow template changes');
    $f->showIf = "editModes=edit";
    $f->columnWidth = 34;
    $f->description = __('If checked, edit mode will allow template changes (if user has the "page-template" permission). There are no warnings about data loss on template change, so be careful with this.');
    $f->notes = __("This can be extremely destructive, use with extreme caution!");
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['allowTemplateChanges'] : $data['allowTemplateChanges']) ? 'checked' : '' );
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldRadios");
    $f->attr('name', 'trashOrDelete');
    $f->label = __('Trash or Delete');
    $f->columnWidth = 33;
    $f->description = __('Whether you want deleted pages moved to the trash or permanently deleted.');
    $f->addOption("trash","Trash");
    $f->addOption("delete","Delete");
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['trashOrDelete'] : $data['trashOrDelete'];
    $fieldset->add($f);

    $fieldset = wire('modules')->get("InputfieldFieldset");
    $fieldset->attr('id', 'batch_child_editor_data_entry_fieldset');
    $fieldset->label = __("Data entry / CSV import settings");
    $fieldset->showIf = "editModes=add|update|replace";
    $fieldset->collapsed = Inputfield::collapsedYes;
    $wrapper->add($fieldset);

    $f = wire('modules')->get("InputfieldCheckboxes");
    $f->attr('name', 'csvOptions');
    $f->label = __('Page data options');
    $f->showIf = "editModes=add|update|replace";
    $f->required = true;
    $f->requiredIf = "editModes=add|update|replace";
    $f->columnWidth = wire('input')->get->id ? 25 : 50;
    $f->description = __('Which page entry options do you want available.');
    $f->notes = __("For creating page title/names only, then Text / Paste is likely the most relevant option. CSV options to the right only relevant if populating other page fields in addition to the title/name.");
    $f->addOption("paste","Text / Paste");
    $f->addOption("link","Link (URL)");
    $f->addOption("upload","Upload");
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['csvOptions'] : $data['csvOptions'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckboxes");
    $f->attr('name', 'csvOptionsCollapsed');
    $f->label = __('Page data options collapsed status');
    $f->showIf = "editModes=add|update|replace";
    $f->columnWidth = wire('input')->get->id ? 25 : 50;
    $f->description = __('Which page entry options do you want open vs collapsed.');
    $f->notes = __("Checked options will be open by default.");
    $f->addOption("paste","Text / Paste");
    $f->addOption("link","Link (URL)");
    $f->addOption("upload","Upload");
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['csvOptionsCollapsed'] : $data['csvOptionsCollapsed'];
    $fieldset->add($f);

    //only for page context settings, NOT module config settings
    if(wire('input')->get->id) {
        $f = wire('modules')->get("InputfieldTextarea");
        $f->name = 'fieldPairings';
        $f->label = __('CSV field pairings');
        $f->description = __("Enter CSV column number and Processwire field name pairs to match up when importing. If empty, all CSV columns will be imported in order and therefore must match the number of fields in the template for this page.");
        $f->notes = __("Column numbers start at 1 so in this example we are excluding the 3rd column in the CSV file:\n1:title\n2:body\n4:notes\n5:parentfield.subfield\n\nNB Unless the only modes are \"Edit\" and \"Update\", you must include at least the \"title\" field, but all other fields are optional.");
        $f->showIf = "editModes=add|update|replace";
        $f->columnWidth = 50;
        $f->value = isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['fieldPairings'] : '';
        $fieldset->add($f);
    }

    $f = wire('modules')->get("InputfieldText");
    $f->name = 'csvImportFieldSeparator';
    $f->label = __('CSV fields separated with');
    $f->showIf = "editModes=add|update|replace";
    $f->notes = __('For tab separated, enter: tab');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['csvImportFieldSeparator'] : $data['csvImportFieldSeparator'];
    $f->columnWidth = 25;
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->name = 'csvImportFieldEnclosure';
    $f->label = __('CSV field enclosure');
    $f->showIf = "editModes=add|update|replace";
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['csvImportFieldEnclosure'] : $data['csvImportFieldEnclosure'];
    $f->columnWidth = 25;
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'ignoreFirstRow');
    $f->label = __('CSV ignore the first row');
    $f->description = __('Use this if the first row contains column/field labels.');
    $f->showIf = "editModes=add|update|replace";
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['ignoreFirstRow'] : $data['ignoreFirstRow']) ? 'checked' : '' );
    $f->columnWidth = 25;
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'allowOverrideCsvImportSettings');
    $f->label = __('User override CSV settings');
    $f->description = __('Allow user to override CSV separator, enclosure, and ignore first row settings.');
    $f->showIf = "editModes=add|update|replace";
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['allowOverrideCsvImportSettings'] : $data['allowOverrideCsvImportSettings']) ? 'checked' : '' );
    $f->columnWidth = 25;
    $fieldset->add($f);

    $fieldset = wire('modules')->get("InputfieldFieldset");
    $fieldset->attr('id', 'batch_child_editor_csv_export_fieldset');
    $fieldset->label = __('CSV export settings');
    $fieldset->description = __('If you want to specify the fields to export, you need to define them separately for each parent page by setting the Configurable pages first. All these settings can also be overriden on a page specific basis.');
    $fieldset->showIf = "editModes=export";
    $fieldset->collapsed = Inputfield::collapsedYes;
    $wrapper->add($fieldset);

    //only for page context settings, NOT module config settings
    if(wire('input')->get->id) {
        $f = wire('modules')->get("InputfieldAsmSelect");
        $f->name = "exportFields";
        $f->showIf = "editModes=export";
        $f->label = __('Fields to export');
        $f->description = __('Choose and sort the fields to include in the CSV export');

        //system fields
        foreach($data['systemFields'] as $systemField => $systemFieldLabel) {
            $f->addOption($systemField, $systemFieldLabel);
        }
        $allFields = array();
        foreach(wire('pages')->get(wire('input')->get->id)->children as $child) {
            foreach($child->fields as $cf) {
                if(!in_array($cf, $allFields)) $allFields[] = $cf;
            }
        }

        //custom template fields for all child pages
        foreach($allFields as $pf) {
            $f->addOption($pf->name, $pf->label ? $pf->label : $pf->name);
            $f->value = $pf->name;
        }
        $f->value = isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['exportFields'] : '';
        $fieldset->add($f);
    }

    $f = wire('modules')->get("InputfieldText");
    $f->name = 'csvExportFieldSeparator';
    $f->label = __('CSV fields separated with');
    $f->showIf = "editModes=export";
    $f->notes = __('For tab separated, enter: tab');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['csvExportFieldSeparator'] : $data['csvExportFieldSeparator'];
    $f->columnWidth = 20;
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->name = 'csvExportFieldEnclosure';
    $f->label = __('CSV field enclosure');
    $f->showIf = "editModes=export";
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['csvExportFieldEnclosure'] : $data['csvExportFieldEnclosure'];
    $f->columnWidth = 20;
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->name = 'csvExportExtension';
    $f->label = __('File extension');
    $f->showIf = "editModes=export";
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['csvExportExtension'] : $data['csvExportExtension'];
    $f->columnWidth = 20;
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'columnsFirstRow');
    $f->label = __('Column labels');
    $f->label2 = __('Put column names in the first row');
    $f->showIf = "editModes=export";
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['columnsFirstRow'] : $data['columnsFirstRow']) ? 'checked' : '' );
    $f->columnWidth = 20;
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'multipleValuesSeparator');
    $f->label = __('Multiple values separator');
    $f->description = __('Separator for multiple values like Page fields, files/images, multiplier, etc.');
    $f->notes = __('Default is | Other useful options include \r for new lines when importing into Excel.');
    $f->showIf = "editModes=export";
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['multipleValuesSeparator'] : $data['multipleValuesSeparator'];
    $f->columnWidth = 20;
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'allowOverrideCsvExportSettings');
    $f->label = __('User override CSV settings');
    $f->description = __('Allow user to override Fields to export, CSV separator, enclosure, and column labels in first row settings.');
    $f->showIf = "editModes=export";
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['allowOverrideCsvExportSettings'] : $data['allowOverrideCsvExportSettings']) ? 'checked' : '' );
    $fieldset->add($f);

    $fieldset = wire('modules')->get("InputfieldFieldset");
    $fieldset->attr('id', 'batch_child_editor_position_fieldset');
    $fieldset->label = __("Editor position settings");
    $fieldset->collapsed = Inputfield::collapsedYes;
    $wrapper->add($fieldset);

    $f = wire('modules')->get("InputfieldRadios");
    $f->attr('name', 'position');
    $f->label = __('Position');
    $f->columnWidth = 33;
    $f->description = __('Where to position the Batch Child Editor tool. Replace will remove the existing page tree. New Tab will put this editor in a new tab.');
    $f->addOption("top","Top");
    $f->addOption("bottom","Bottom");
    $f->addOption("replace","Replace");
    $f->addOption("newTab","New Tab");
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['position'] : $data['position'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldCheckbox");
    $f->attr('name', 'loadOpen');
    $f->label = __('Load open, not collapsed');
    $f->showIf = "position!=newTab";
    $f->columnWidth = 34;
    $f->description = __('If checked, batch child editor will initially be open, not collapsed.');
    $f->attr('checked', ($pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['loadOpen'] : $data['loadOpen']) ? 'checked' : '' );
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'tabName');
    $f->label = __('Tab name');
    $f->showIf = "position=newTab";
    $f->required = 1;
    $f->requiredIf = "position=newTab";
    $f->columnWidth = 33;
    $f->description = __('Name for the new tab.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['tabName'] : $data['tabName'];
    $fieldset->add($f);

    $fieldset = wire('modules')->get("InputfieldFieldset");
    $fieldset->attr('id', 'batch_child_editor_custom_text_fieldset');
    $fieldset->label = __("Custom labels, descriptions and notes");
    $fieldset->collapsed = Inputfield::collapsedYes;
    $wrapper->add($fieldset);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'editModeTitle');
    $f->label = __('Edit mode title');
    $f->showIf = "editModes=edit";
    $f->columnWidth = 33;
    $f->description = __('Custom title in Edit mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['editModeTitle'] : $data['editModeTitle'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'editModeDescription');
    $f->label = __('Edit mode description');
    $f->showIf = "editModes=edit";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Edit mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['editModeDescription'] : $data['editModeDescription'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'editModeNotes');
    $f->label = __('Edit mode notes');
    $f->showIf = "editModes=edit";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Edit mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['editModeNotes'] : $data['editModeNotes'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'addModeTitle');
    $f->label = __('Add mode title');
    $f->showIf = "editModes=add";
    $f->columnWidth = 33;
    $f->description = __('Custom title for Add mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['addModeTitle'] : $data['addModeTitle'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'addModeDescription');
    $f->label = __('Add mode description');
    $f->showIf = "editModes=add";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Add mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['addModeDescription'] : $data['addModeDescription'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'addModeNotes');
    $f->label = __('Add mode notes');
    $f->showIf = "editModes=add";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Add mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['addModeNotes'] : $data['addModeNotes'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'updateModeTitle');
    $f->label = __('Update mode title');
    $f->showIf = "editModes=update";
    $f->columnWidth = 33;
    $f->description = __('Custom title for Update mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['updateModeTitle'] : $data['updateModeTitle'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'updateModeDescription');
    $f->label = __('Update mode description');
    $f->showIf = "editModes=update";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Update mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['updateModeDescription'] : $data['updateModeDescription'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'updateModeNotes');
    $f->label = __('Update mode notes');
    $f->showIf = "editModes=update";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Update mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['updateModeNotes'] : $data['updateModeNotes'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'replaceModeTitle');
    $f->label = __('Replace mode title');
    $f->showIf = "editModes=replace";
    $f->columnWidth = 33;
    $f->description = __('Custom title for Replace mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['replaceModeTitle'] : $data['replaceModeTitle'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'replaceModeDescription');
    $f->label = __('Replace mode description');
    $f->showIf = "editModes=replace";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Replace mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['replaceModeDescription'] : $data['replaceModeDescription'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'replaceModeNotes');
    $f->label = __('Replace mode notes');
    $f->showIf = "editModes=replace";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Replace mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['replaceModeNotes'] : $data['replaceModeNotes'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldText");
    $f->attr('name', 'exportModeTitle');
    $f->label = __('Export mode title');
    $f->showIf = "editModes=export";
    $f->columnWidth = 33;
    $f->description = __('Custom title for Export mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['exportModeTitle'] : $data['exportModeTitle'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'exportModeDescription');
    $f->label = __('Export mode description');
    $f->showIf = "editModes=export";
    $f->columnWidth = 34;
    $f->description = __('Custom text for description in Export mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['exportModeDescription'] : $data['exportModeDescription'];
    $fieldset->add($f);

    $f = wire('modules')->get("InputfieldTextarea");
    $f->attr('name', 'exportModeNotes');
    $f->label = __('Export mode notes');
    $f->showIf = "editModes=export";
    $f->columnWidth = 33;
    $f->description = __('Custom text for notes in Export mode.');
    $f->value = $pid && isset($data['pageSettings'][$pid]) ? $data['pageSettings'][$pid]['exportModeNotes'] : $data['exportModeNotes'];
    $fieldset->add($f);

}
